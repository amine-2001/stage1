{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _mongoObject = _interopRequireDefault(require(\"mongo-object\"));\n\nvar _lodash = _interopRequireDefault(require(\"lodash.omit\"));\n\nvar _lodash2 = _interopRequireDefault(require(\"lodash.isobject\"));\n\nvar _lodash3 = _interopRequireDefault(require(\"lodash.union\"));\n\nvar _lodash4 = _interopRequireDefault(require(\"lodash.includes\"));\n\nvar _SimpleSchema = require(\"./SimpleSchema\");\n\nvar _utility = require(\"./utility\");\n\nvar _typeValidator = _interopRequireDefault(require(\"./validation/typeValidator\"));\n\nvar _requiredValidator = _interopRequireDefault(require(\"./validation/requiredValidator\"));\n\nvar _allowedValuesValidator = _interopRequireDefault(require(\"./validation/allowedValuesValidator\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction shouldCheck(key) {\n  if (key === '$pushAll') throw new Error('$pushAll is not supported; use $push + $each');\n  return ['$pull', '$pullAll', '$pop', '$slice'].indexOf(key) === -1;\n}\n\nfunction doValidation(_ref) {\n  var extendedCustomContext = _ref.extendedCustomContext,\n      ignoreTypes = _ref.ignoreTypes,\n      isModifier = _ref.isModifier,\n      isUpsert = _ref.isUpsert,\n      keysToValidate = _ref.keysToValidate,\n      mongoObject = _ref.mongoObject,\n      obj = _ref.obj,\n      schema = _ref.schema,\n      validationContext = _ref.validationContext; // First do some basic checks of the object, and throw errors if necessary\n\n  if (!(0, _lodash2[\"default\"])(obj)) {\n    throw new Error('The first argument of validate() must be an object');\n  }\n\n  if (!isModifier && (0, _utility.looksLikeModifier)(obj)) {\n    throw new Error('When the validation object contains mongo operators, you must set the modifier option to true');\n  }\n\n  var validationErrors = []; // Validation function called for each affected key\n\n  function validate(val, affectedKey, affectedKeyGeneric, def, op, isInArrayItemObject, isInSubObject) {\n    // Get the schema for this key, marking invalid if there isn't one.\n    if (!def) {\n      // We don't need KEY_NOT_IN_SCHEMA error for $unset and we also don't need to continue\n      if (op === '$unset') return;\n      validationErrors.push({\n        name: affectedKey,\n        type: _SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA,\n        value: val\n      });\n      return;\n    } // For $rename, make sure that the new name is allowed by the schema\n\n\n    if (op === '$rename' && !schema.allowsKey(val)) {\n      validationErrors.push({\n        name: val,\n        type: _SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA,\n        value: null\n      });\n      return;\n    } // Prepare the context object for the validator functions\n\n\n    var fieldParentNameWithEndDot = (0, _utility.getParentOfKey)(affectedKey, true);\n    var fieldParentName = fieldParentNameWithEndDot.slice(0, -1);\n\n    function getFieldInfo(key) {\n      // Create mongoObject if necessary, cache for speed\n      if (!mongoObject) mongoObject = new _mongoObject[\"default\"](obj, schema.blackboxKeys());\n      var keyInfo = mongoObject.getInfoForKey(key) || {};\n      return {\n        isSet: keyInfo.value !== undefined,\n        value: keyInfo.value,\n        operator: keyInfo.operator || null\n      };\n    }\n\n    var fieldValidationErrors = [];\n\n    var validatorContext = _objectSpread({\n      addValidationErrors: function addValidationErrors(errors) {\n        errors.forEach(function (error) {\n          return fieldValidationErrors.push(error);\n        });\n      },\n      field: function field(fName) {\n        return getFieldInfo(fName);\n      },\n      genericKey: affectedKeyGeneric,\n      isInArrayItemObject: isInArrayItemObject,\n      isInSubObject: isInSubObject,\n      isModifier: isModifier,\n      isSet: val !== undefined,\n      key: affectedKey,\n      obj: obj,\n      operator: op,\n      parentField: function parentField() {\n        return getFieldInfo(fieldParentName);\n      },\n      siblingField: function siblingField(fName) {\n        return getFieldInfo(fieldParentNameWithEndDot + fName);\n      },\n      validationContext: validationContext,\n      value: val,\n      // Value checks are not necessary for null or undefined values,\n      // except for null array items, or for $unset or $rename values\n      valueShouldBeChecked: op !== '$unset' && op !== '$rename' && (val !== undefined && val !== null || affectedKeyGeneric.slice(-2) === '.$' && val === null)\n    }, extendedCustomContext || {});\n\n    var builtInValidators = [_requiredValidator[\"default\"], _typeValidator[\"default\"], _allowedValuesValidator[\"default\"]];\n    var validators = builtInValidators.concat(schema._validators).concat(_SimpleSchema.SimpleSchema._validators); // Loop through each of the definitions in the SimpleSchemaGroup.\n    // If any return true, we're valid.\n\n    var fieldIsValid = def.type.some(function (typeDef) {\n      var finalValidatorContext = _objectSpread({}, validatorContext, {\n        // Take outer definition props like \"optional\" and \"label\"\n        // and add them to inner props like \"type\" and \"min\"\n        definition: _objectSpread({}, (0, _lodash[\"default\"])(def, 'type'), {}, typeDef)\n      }); // Add custom field validators to the list after the built-in\n      // validators but before the schema and global validators.\n\n\n      var fieldValidators = validators.slice(0);\n\n      if (typeof typeDef.custom === 'function') {\n        fieldValidators.splice(builtInValidators.length, 0, typeDef.custom);\n      } // We use _.every just so that we don't continue running more validator\n      // functions after the first one returns false or an error string.\n\n\n      return fieldValidators.every(function (validator) {\n        var result = validator.call(finalValidatorContext); // If the validator returns a string, assume it is the\n        // error type.\n\n        if (typeof result === 'string') {\n          fieldValidationErrors.push({\n            name: affectedKey,\n            type: result,\n            value: val\n          });\n          return false;\n        } // If the validator returns an object, assume it is an\n        // error object.\n\n\n        if (_typeof(result) === 'object' && result !== null) {\n          fieldValidationErrors.push(_objectSpread({\n            name: affectedKey,\n            value: val\n          }, result));\n          return false;\n        } // If the validator returns false, assume they already\n        // called this.addValidationErrors within the function\n\n\n        if (result === false) return false; // Any other return value we assume means it was valid\n\n        return true;\n      });\n    });\n\n    if (!fieldIsValid) {\n      validationErrors = validationErrors.concat(fieldValidationErrors);\n    }\n  } // The recursive function\n\n\n  function checkObj(_ref2) {\n    var val = _ref2.val,\n        affectedKey = _ref2.affectedKey,\n        operator = _ref2.operator,\n        _ref2$isInArrayItemOb = _ref2.isInArrayItemObject,\n        isInArrayItemObject = _ref2$isInArrayItemOb === void 0 ? false : _ref2$isInArrayItemOb,\n        _ref2$isInSubObject = _ref2.isInSubObject,\n        isInSubObject = _ref2$isInSubObject === void 0 ? false : _ref2$isInSubObject;\n    var affectedKeyGeneric;\n    var def;\n\n    if (affectedKey) {\n      // When we hit a blackbox key, we don't progress any further\n      if (schema.keyIsInBlackBox(affectedKey)) return; // Make a generic version of the affected key, and use that\n      // to get the schema for this key.\n\n      affectedKeyGeneric = _mongoObject[\"default\"].makeKeyGeneric(affectedKey);\n      var shouldValidateKey = !keysToValidate || keysToValidate.some(function (keyToValidate) {\n        return keyToValidate === affectedKey || keyToValidate === affectedKeyGeneric || affectedKey.startsWith(\"\".concat(keyToValidate, \".\")) || affectedKeyGeneric.startsWith(\"\".concat(keyToValidate, \".\"));\n      }); // Perform validation for this key\n\n      def = schema.getDefinition(affectedKey);\n\n      if (shouldValidateKey) {\n        validate(val, affectedKey, affectedKeyGeneric, def, operator, isInArrayItemObject, isInSubObject);\n      }\n    } // If affectedKeyGeneric is undefined due to this being the first run of this\n    // function, objectKeys will return the top-level keys.\n\n\n    var childKeys = schema.objectKeys(affectedKeyGeneric); // Temporarily convert missing objects to empty objects\n    // so that the looping code will be called and required\n    // descendent keys can be validated.\n\n    if ((val === undefined || val === null) && (!def || !def.optional && childKeys && childKeys.length > 0)) {\n      val = {};\n    } // Loop through arrays\n\n\n    if (Array.isArray(val)) {\n      val.forEach(function (v, i) {\n        checkObj({\n          val: v,\n          affectedKey: \"\".concat(affectedKey, \".\").concat(i),\n          operator: operator\n        });\n      });\n    } else if ((0, _utility.isObjectWeShouldTraverse)(val) && (!def || schema._blackboxKeys.indexOf(affectedKey) === -1)) {\n      // Loop through object keys\n      // Get list of present keys\n      var presentKeys = Object.keys(val); // Check all present keys plus all keys defined by the schema.\n      // This allows us to detect extra keys not allowed by the schema plus\n      // any missing required keys, and to run any custom functions for other keys.\n\n      var keysToCheck = (0, _lodash3[\"default\"])(presentKeys, childKeys); // If this object is within an array, make sure we check for\n      // required as if it's not a modifier\n\n      isInArrayItemObject = affectedKeyGeneric && affectedKeyGeneric.slice(-2) === '.$'; // Check all keys in the merged list\n\n      keysToCheck.forEach(function (key) {\n        checkObj({\n          val: val[key],\n          affectedKey: (0, _utility.appendAffectedKey)(affectedKey, key),\n          operator: operator,\n          isInArrayItemObject: isInArrayItemObject,\n          isInSubObject: true\n        });\n      });\n    }\n  }\n\n  function checkModifier(mod) {\n    // Loop through operators\n    Object.keys(mod).forEach(function (op) {\n      var opObj = mod[op]; // If non-operators are mixed in, throw error\n\n      if (op.slice(0, 1) !== '$') {\n        throw new Error(\"Expected '\".concat(op, \"' to be a modifier operator like '$set'\"));\n      }\n\n      if (shouldCheck(op)) {\n        // For an upsert, missing props would not be set if an insert is performed,\n        // so we check them all with undefined value to force any 'required' checks to fail\n        if (isUpsert && (op === '$set' || op === '$setOnInsert')) {\n          var presentKeys = Object.keys(opObj);\n          schema.objectKeys().forEach(function (schemaKey) {\n            if (!(0, _lodash4[\"default\"])(presentKeys, schemaKey)) {\n              checkObj({\n                val: undefined,\n                affectedKey: schemaKey,\n                operator: op\n              });\n            }\n          });\n        } // Don't use forEach here because it will not properly handle an\n        // object that has a property named `length`\n\n\n        Object.keys(opObj).forEach(function (k) {\n          var v = opObj[k];\n\n          if (op === '$push' || op === '$addToSet') {\n            if (_typeof(v) === 'object' && '$each' in v) {\n              v = v.$each;\n            } else {\n              k = \"\".concat(k, \".0\");\n            }\n          }\n\n          checkObj({\n            val: v,\n            affectedKey: k,\n            operator: op\n          });\n        });\n      }\n    });\n  } // Kick off the validation\n\n\n  if (isModifier) {\n    checkModifier(obj);\n  } else {\n    checkObj({\n      val: obj\n    });\n  } // Custom whole-doc validators\n\n\n  var docValidators = schema._docValidators.concat(_SimpleSchema.SimpleSchema._docValidators);\n\n  docValidators.forEach(function (func) {\n    var errors = func(obj);\n    if (!Array.isArray(errors)) throw new Error('Custom doc validator must return an array of error objects');\n    if (errors.length) validationErrors = validationErrors.concat(errors);\n  });\n  var addedFieldNames = [];\n  validationErrors = validationErrors.filter(function (errObj) {\n    // Remove error types the user doesn't care about\n    if ((0, _lodash4[\"default\"])(ignoreTypes, errObj.type)) return false; // Make sure there is only one error per fieldName\n\n    if ((0, _lodash4[\"default\"])(addedFieldNames, errObj.name)) return false;\n    addedFieldNames.push(errObj.name);\n    return true;\n  });\n  return validationErrors;\n}\n\nvar _default = doValidation;\nexports[\"default\"] = _default;\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;","map":{"version":3,"sources":["C:/Users/asus/Desktop/new template/myadmin-lite/node_modules/simpl-schema/dist/doValidation.js"],"names":["Object","defineProperty","exports","value","_mongoObject","_interopRequireDefault","require","_lodash","_lodash2","_lodash3","_lodash4","_SimpleSchema","_utility","_typeValidator","_requiredValidator","_allowedValuesValidator","obj","__esModule","_typeof","Symbol","iterator","constructor","prototype","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","shouldCheck","Error","indexOf","doValidation","_ref","extendedCustomContext","ignoreTypes","isModifier","isUpsert","keysToValidate","mongoObject","schema","validationContext","looksLikeModifier","validationErrors","validate","val","affectedKey","affectedKeyGeneric","def","op","isInArrayItemObject","isInSubObject","name","type","SimpleSchema","ErrorTypes","KEY_NOT_IN_SCHEMA","allowsKey","fieldParentNameWithEndDot","getParentOfKey","fieldParentName","slice","getFieldInfo","blackboxKeys","keyInfo","getInfoForKey","isSet","undefined","operator","fieldValidationErrors","validatorContext","addValidationErrors","errors","error","field","fName","genericKey","parentField","siblingField","valueShouldBeChecked","builtInValidators","validators","concat","_validators","fieldIsValid","some","typeDef","finalValidatorContext","definition","fieldValidators","custom","splice","every","validator","result","call","checkObj","_ref2","_ref2$isInArrayItemOb","_ref2$isInSubObject","keyIsInBlackBox","makeKeyGeneric","shouldValidateKey","keyToValidate","startsWith","getDefinition","childKeys","objectKeys","optional","Array","isArray","v","isObjectWeShouldTraverse","_blackboxKeys","presentKeys","keysToCheck","appendAffectedKey","checkModifier","mod","opObj","schemaKey","k","$each","docValidators","_docValidators","func","addedFieldNames","errObj","_default","module","default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _mongoObject = _interopRequireDefault(require(\"mongo-object\"));\n\nvar _lodash = _interopRequireDefault(require(\"lodash.omit\"));\n\nvar _lodash2 = _interopRequireDefault(require(\"lodash.isobject\"));\n\nvar _lodash3 = _interopRequireDefault(require(\"lodash.union\"));\n\nvar _lodash4 = _interopRequireDefault(require(\"lodash.includes\"));\n\nvar _SimpleSchema = require(\"./SimpleSchema\");\n\nvar _utility = require(\"./utility\");\n\nvar _typeValidator = _interopRequireDefault(require(\"./validation/typeValidator\"));\n\nvar _requiredValidator = _interopRequireDefault(require(\"./validation/requiredValidator\"));\n\nvar _allowedValuesValidator = _interopRequireDefault(require(\"./validation/allowedValuesValidator\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction shouldCheck(key) {\n  if (key === '$pushAll') throw new Error('$pushAll is not supported; use $push + $each');\n  return ['$pull', '$pullAll', '$pop', '$slice'].indexOf(key) === -1;\n}\n\nfunction doValidation(_ref) {\n  var extendedCustomContext = _ref.extendedCustomContext,\n      ignoreTypes = _ref.ignoreTypes,\n      isModifier = _ref.isModifier,\n      isUpsert = _ref.isUpsert,\n      keysToValidate = _ref.keysToValidate,\n      mongoObject = _ref.mongoObject,\n      obj = _ref.obj,\n      schema = _ref.schema,\n      validationContext = _ref.validationContext;\n\n  // First do some basic checks of the object, and throw errors if necessary\n  if (!(0, _lodash2[\"default\"])(obj)) {\n    throw new Error('The first argument of validate() must be an object');\n  }\n\n  if (!isModifier && (0, _utility.looksLikeModifier)(obj)) {\n    throw new Error('When the validation object contains mongo operators, you must set the modifier option to true');\n  }\n\n  var validationErrors = []; // Validation function called for each affected key\n\n  function validate(val, affectedKey, affectedKeyGeneric, def, op, isInArrayItemObject, isInSubObject) {\n    // Get the schema for this key, marking invalid if there isn't one.\n    if (!def) {\n      // We don't need KEY_NOT_IN_SCHEMA error for $unset and we also don't need to continue\n      if (op === '$unset') return;\n      validationErrors.push({\n        name: affectedKey,\n        type: _SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA,\n        value: val\n      });\n      return;\n    } // For $rename, make sure that the new name is allowed by the schema\n\n\n    if (op === '$rename' && !schema.allowsKey(val)) {\n      validationErrors.push({\n        name: val,\n        type: _SimpleSchema.SimpleSchema.ErrorTypes.KEY_NOT_IN_SCHEMA,\n        value: null\n      });\n      return;\n    } // Prepare the context object for the validator functions\n\n\n    var fieldParentNameWithEndDot = (0, _utility.getParentOfKey)(affectedKey, true);\n    var fieldParentName = fieldParentNameWithEndDot.slice(0, -1);\n\n    function getFieldInfo(key) {\n      // Create mongoObject if necessary, cache for speed\n      if (!mongoObject) mongoObject = new _mongoObject[\"default\"](obj, schema.blackboxKeys());\n      var keyInfo = mongoObject.getInfoForKey(key) || {};\n      return {\n        isSet: keyInfo.value !== undefined,\n        value: keyInfo.value,\n        operator: keyInfo.operator || null\n      };\n    }\n\n    var fieldValidationErrors = [];\n\n    var validatorContext = _objectSpread({\n      addValidationErrors: function addValidationErrors(errors) {\n        errors.forEach(function (error) {\n          return fieldValidationErrors.push(error);\n        });\n      },\n      field: function field(fName) {\n        return getFieldInfo(fName);\n      },\n      genericKey: affectedKeyGeneric,\n      isInArrayItemObject: isInArrayItemObject,\n      isInSubObject: isInSubObject,\n      isModifier: isModifier,\n      isSet: val !== undefined,\n      key: affectedKey,\n      obj: obj,\n      operator: op,\n      parentField: function parentField() {\n        return getFieldInfo(fieldParentName);\n      },\n      siblingField: function siblingField(fName) {\n        return getFieldInfo(fieldParentNameWithEndDot + fName);\n      },\n      validationContext: validationContext,\n      value: val,\n      // Value checks are not necessary for null or undefined values,\n      // except for null array items, or for $unset or $rename values\n      valueShouldBeChecked: op !== '$unset' && op !== '$rename' && (val !== undefined && val !== null || affectedKeyGeneric.slice(-2) === '.$' && val === null)\n    }, extendedCustomContext || {});\n\n    var builtInValidators = [_requiredValidator[\"default\"], _typeValidator[\"default\"], _allowedValuesValidator[\"default\"]];\n    var validators = builtInValidators.concat(schema._validators).concat(_SimpleSchema.SimpleSchema._validators); // Loop through each of the definitions in the SimpleSchemaGroup.\n    // If any return true, we're valid.\n\n    var fieldIsValid = def.type.some(function (typeDef) {\n      var finalValidatorContext = _objectSpread({}, validatorContext, {\n        // Take outer definition props like \"optional\" and \"label\"\n        // and add them to inner props like \"type\" and \"min\"\n        definition: _objectSpread({}, (0, _lodash[\"default\"])(def, 'type'), {}, typeDef)\n      }); // Add custom field validators to the list after the built-in\n      // validators but before the schema and global validators.\n\n\n      var fieldValidators = validators.slice(0);\n\n      if (typeof typeDef.custom === 'function') {\n        fieldValidators.splice(builtInValidators.length, 0, typeDef.custom);\n      } // We use _.every just so that we don't continue running more validator\n      // functions after the first one returns false or an error string.\n\n\n      return fieldValidators.every(function (validator) {\n        var result = validator.call(finalValidatorContext); // If the validator returns a string, assume it is the\n        // error type.\n\n        if (typeof result === 'string') {\n          fieldValidationErrors.push({\n            name: affectedKey,\n            type: result,\n            value: val\n          });\n          return false;\n        } // If the validator returns an object, assume it is an\n        // error object.\n\n\n        if (_typeof(result) === 'object' && result !== null) {\n          fieldValidationErrors.push(_objectSpread({\n            name: affectedKey,\n            value: val\n          }, result));\n          return false;\n        } // If the validator returns false, assume they already\n        // called this.addValidationErrors within the function\n\n\n        if (result === false) return false; // Any other return value we assume means it was valid\n\n        return true;\n      });\n    });\n\n    if (!fieldIsValid) {\n      validationErrors = validationErrors.concat(fieldValidationErrors);\n    }\n  } // The recursive function\n\n\n  function checkObj(_ref2) {\n    var val = _ref2.val,\n        affectedKey = _ref2.affectedKey,\n        operator = _ref2.operator,\n        _ref2$isInArrayItemOb = _ref2.isInArrayItemObject,\n        isInArrayItemObject = _ref2$isInArrayItemOb === void 0 ? false : _ref2$isInArrayItemOb,\n        _ref2$isInSubObject = _ref2.isInSubObject,\n        isInSubObject = _ref2$isInSubObject === void 0 ? false : _ref2$isInSubObject;\n    var affectedKeyGeneric;\n    var def;\n\n    if (affectedKey) {\n      // When we hit a blackbox key, we don't progress any further\n      if (schema.keyIsInBlackBox(affectedKey)) return; // Make a generic version of the affected key, and use that\n      // to get the schema for this key.\n\n      affectedKeyGeneric = _mongoObject[\"default\"].makeKeyGeneric(affectedKey);\n      var shouldValidateKey = !keysToValidate || keysToValidate.some(function (keyToValidate) {\n        return keyToValidate === affectedKey || keyToValidate === affectedKeyGeneric || affectedKey.startsWith(\"\".concat(keyToValidate, \".\")) || affectedKeyGeneric.startsWith(\"\".concat(keyToValidate, \".\"));\n      }); // Perform validation for this key\n\n      def = schema.getDefinition(affectedKey);\n\n      if (shouldValidateKey) {\n        validate(val, affectedKey, affectedKeyGeneric, def, operator, isInArrayItemObject, isInSubObject);\n      }\n    } // If affectedKeyGeneric is undefined due to this being the first run of this\n    // function, objectKeys will return the top-level keys.\n\n\n    var childKeys = schema.objectKeys(affectedKeyGeneric); // Temporarily convert missing objects to empty objects\n    // so that the looping code will be called and required\n    // descendent keys can be validated.\n\n    if ((val === undefined || val === null) && (!def || !def.optional && childKeys && childKeys.length > 0)) {\n      val = {};\n    } // Loop through arrays\n\n\n    if (Array.isArray(val)) {\n      val.forEach(function (v, i) {\n        checkObj({\n          val: v,\n          affectedKey: \"\".concat(affectedKey, \".\").concat(i),\n          operator: operator\n        });\n      });\n    } else if ((0, _utility.isObjectWeShouldTraverse)(val) && (!def || schema._blackboxKeys.indexOf(affectedKey) === -1)) {\n      // Loop through object keys\n      // Get list of present keys\n      var presentKeys = Object.keys(val); // Check all present keys plus all keys defined by the schema.\n      // This allows us to detect extra keys not allowed by the schema plus\n      // any missing required keys, and to run any custom functions for other keys.\n\n      var keysToCheck = (0, _lodash3[\"default\"])(presentKeys, childKeys); // If this object is within an array, make sure we check for\n      // required as if it's not a modifier\n\n      isInArrayItemObject = affectedKeyGeneric && affectedKeyGeneric.slice(-2) === '.$'; // Check all keys in the merged list\n\n      keysToCheck.forEach(function (key) {\n        checkObj({\n          val: val[key],\n          affectedKey: (0, _utility.appendAffectedKey)(affectedKey, key),\n          operator: operator,\n          isInArrayItemObject: isInArrayItemObject,\n          isInSubObject: true\n        });\n      });\n    }\n  }\n\n  function checkModifier(mod) {\n    // Loop through operators\n    Object.keys(mod).forEach(function (op) {\n      var opObj = mod[op]; // If non-operators are mixed in, throw error\n\n      if (op.slice(0, 1) !== '$') {\n        throw new Error(\"Expected '\".concat(op, \"' to be a modifier operator like '$set'\"));\n      }\n\n      if (shouldCheck(op)) {\n        // For an upsert, missing props would not be set if an insert is performed,\n        // so we check them all with undefined value to force any 'required' checks to fail\n        if (isUpsert && (op === '$set' || op === '$setOnInsert')) {\n          var presentKeys = Object.keys(opObj);\n          schema.objectKeys().forEach(function (schemaKey) {\n            if (!(0, _lodash4[\"default\"])(presentKeys, schemaKey)) {\n              checkObj({\n                val: undefined,\n                affectedKey: schemaKey,\n                operator: op\n              });\n            }\n          });\n        } // Don't use forEach here because it will not properly handle an\n        // object that has a property named `length`\n\n\n        Object.keys(opObj).forEach(function (k) {\n          var v = opObj[k];\n\n          if (op === '$push' || op === '$addToSet') {\n            if (_typeof(v) === 'object' && '$each' in v) {\n              v = v.$each;\n            } else {\n              k = \"\".concat(k, \".0\");\n            }\n          }\n\n          checkObj({\n            val: v,\n            affectedKey: k,\n            operator: op\n          });\n        });\n      }\n    });\n  } // Kick off the validation\n\n\n  if (isModifier) {\n    checkModifier(obj);\n  } else {\n    checkObj({\n      val: obj\n    });\n  } // Custom whole-doc validators\n\n\n  var docValidators = schema._docValidators.concat(_SimpleSchema.SimpleSchema._docValidators);\n\n  docValidators.forEach(function (func) {\n    var errors = func(obj);\n    if (!Array.isArray(errors)) throw new Error('Custom doc validator must return an array of error objects');\n    if (errors.length) validationErrors = validationErrors.concat(errors);\n  });\n  var addedFieldNames = [];\n  validationErrors = validationErrors.filter(function (errObj) {\n    // Remove error types the user doesn't care about\n    if ((0, _lodash4[\"default\"])(ignoreTypes, errObj.type)) return false; // Make sure there is only one error per fieldName\n\n    if ((0, _lodash4[\"default\"])(addedFieldNames, errObj.name)) return false;\n    addedFieldNames.push(errObj.name);\n    return true;\n  });\n  return validationErrors;\n}\n\nvar _default = doValidation;\nexports[\"default\"] = _default;\nmodule.exports = exports.default;\nmodule.exports.default = exports.default;"]},"metadata":{},"sourceType":"script"}