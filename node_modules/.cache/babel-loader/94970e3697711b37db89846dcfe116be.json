{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ValidationContext\", {\n  enumerable: true,\n  get: function get() {\n    return _ValidationContext[\"default\"];\n  }\n});\nexports.SimpleSchema = exports.schemaDefinitionOptions = void 0;\n\nvar _clone = _interopRequireDefault(require(\"clone\"));\n\nvar _lodash = _interopRequireDefault(require(\"lodash.every\"));\n\nvar _extend2 = _interopRequireDefault(require(\"extend\"));\n\nvar _lodash2 = _interopRequireDefault(require(\"lodash.includes\"));\n\nvar _lodash3 = _interopRequireDefault(require(\"lodash.isempty\"));\n\nvar _messageBox = _interopRequireDefault(require(\"message-box\"));\n\nvar _mongoObject = _interopRequireDefault(require(\"mongo-object\"));\n\nvar _lodash4 = _interopRequireDefault(require(\"lodash.omit\"));\n\nvar _lodash5 = _interopRequireDefault(require(\"lodash.pick\"));\n\nvar _lodash6 = _interopRequireDefault(require(\"lodash.uniq\"));\n\nvar _humanize = _interopRequireDefault(require(\"./humanize.js\"));\n\nvar _ValidationContext = _interopRequireDefault(require(\"./ValidationContext\"));\n\nvar _SimpleSchemaGroup = _interopRequireDefault(require(\"./SimpleSchemaGroup\"));\n\nvar _regExp = _interopRequireDefault(require(\"./regExp\"));\n\nvar _clean2 = _interopRequireDefault(require(\"./clean\"));\n\nvar _expandShorthand = _interopRequireDefault(require(\"./expandShorthand\"));\n\nvar _utility = require(\"./utility\");\n\nvar _defaultMessages = _interopRequireDefault(require(\"./defaultMessages\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Exported for tests\n\n\nvar schemaDefinitionOptions = ['type', 'label', 'optional', 'required', 'autoValue', 'defaultValue'];\nexports.schemaDefinitionOptions = schemaDefinitionOptions;\nvar oneOfProps = ['type', 'min', 'max', 'minCount', 'maxCount', 'allowedValues', 'exclusiveMin', 'exclusiveMax', 'regEx', 'custom', 'blackbox', 'trim'];\nvar propsThatCanBeFunction = ['label', 'optional', 'min', 'max', 'minCount', 'maxCount', 'allowedValues', 'exclusiveMin', 'exclusiveMax', 'regEx'];\n\nvar SimpleSchema = /*#__PURE__*/function () {\n  function SimpleSchema() {\n    var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        check = _ref.check,\n        cleanOptions = _ref.clean,\n        defaultLabel = _ref.defaultLabel,\n        _ref$humanizeAutoLabe = _ref.humanizeAutoLabels,\n        humanizeAutoLabels = _ref$humanizeAutoLabe === void 0 ? true : _ref$humanizeAutoLabe,\n        _ref$requiredByDefaul = _ref.requiredByDefault,\n        requiredByDefault = _ref$requiredByDefaul === void 0 ? true : _ref$requiredByDefaul,\n        tracker = _ref.tracker;\n\n    _classCallCheck(this, SimpleSchema);\n\n    _defineProperty(this, \"pick\", getPickOrOmit('pick'));\n\n    _defineProperty(this, \"omit\", getPickOrOmit('omit')); // Stash the options object\n\n\n    this._constructorOptions = {\n      check: check,\n      defaultLabel: defaultLabel,\n      humanizeAutoLabels: humanizeAutoLabels,\n      requiredByDefault: requiredByDefault,\n      tracker: tracker\n    }; // Custom validators for this instance\n\n    this._validators = [];\n    this._docValidators = []; // Named validation contexts\n\n    this._validationContexts = {}; // Schema-level defaults for cleaning\n\n    this._cleanOptions = _objectSpread({\n      filter: true,\n      autoConvert: true,\n      removeEmptyStrings: true,\n      trimStrings: true,\n      getAutoValues: true,\n      removeNullsFromArrays: false,\n      extendAutoValueContext: {}\n    }, cleanOptions); // Clone, expanding shorthand, and store the schema object in this._schema\n\n    this._schema = {};\n    this._depsLabels = {};\n    this.extend(schema); // Define default validation error messages\n\n    this.messageBox = new _messageBox[\"default\"]((0, _clone[\"default\"])(_defaultMessages[\"default\"]));\n    this.version = SimpleSchema.version;\n  }\n\n  _createClass(SimpleSchema, [{\n    key: \"forEachAncestorSimpleSchema\",\n    value: function forEachAncestorSimpleSchema(key, func) {\n      var _this = this;\n\n      var genericKey = _mongoObject[\"default\"].makeKeyGeneric(key);\n\n      (0, _utility.forEachKeyAncestor)(genericKey, function (ancestor) {\n        var def = _this._schema[ancestor];\n        if (!def) return;\n        def.type.definitions.forEach(function (typeDef) {\n          if (SimpleSchema.isSimpleSchema(typeDef.type)) {\n            func(typeDef.type, ancestor, genericKey.slice(ancestor.length + 1));\n          }\n        });\n      });\n    }\n    /**\n     * Returns whether the obj is a SimpleSchema object.\n     * @param {Object} [obj] An object to test\n     * @returns {Boolean} True if the given object appears to be a SimpleSchema instance\n     */\n\n  }, {\n    key: \"reactiveLabelDependency\",\n\n    /**\n     * For Meteor apps, add a reactive dependency on the label\n     * for a key.\n     */\n    value: function reactiveLabelDependency(key) {\n      var tracker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._constructorOptions.tracker;\n      if (!key || !tracker) return;\n\n      var genericKey = _mongoObject[\"default\"].makeKeyGeneric(key); // If in this schema\n\n\n      if (this._schema[genericKey]) {\n        if (!this._depsLabels[genericKey]) {\n          this._depsLabels[genericKey] = new tracker.Dependency();\n        }\n\n        this._depsLabels[genericKey].depend();\n\n        return;\n      } // If in subschema\n\n\n      this.forEachAncestorSimpleSchema(key, function (simpleSchema, ancestor, subSchemaKey) {\n        // Pass tracker down so that we get reactivity even if the subschema\n        // didn't have tracker option set\n        simpleSchema.reactiveLabelDependency(subSchemaKey, tracker);\n      });\n    }\n    /**\n     * @param {String} [key] One specific or generic key for which to get the schema.\n     * @returns {Object} The entire schema object or just the definition for one key.\n     *\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\n     * if you want the evaluated definition, where any properties that are functions\n     * have been run to produce a result.\n     */\n\n  }, {\n    key: \"schema\",\n    value: function schema(key) {\n      if (!key) return this._schema;\n\n      var genericKey = _mongoObject[\"default\"].makeKeyGeneric(key);\n\n      var keySchema = this._schema[genericKey]; // If not defined in this schema, see if it's defined in a subschema\n\n      if (!keySchema) {\n        var found = false;\n        this.forEachAncestorSimpleSchema(key, function (simpleSchema, ancestor, subSchemaKey) {\n          if (!found) keySchema = simpleSchema.schema(subSchemaKey);\n          if (keySchema) found = true;\n        });\n      }\n\n      return keySchema;\n    }\n    /**\n     * @returns {Object} The entire schema object with subschemas merged. This is the\n     * equivalent of what schema() returned in SimpleSchema < 2.0\n     *\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\n     * if you want the evaluated definition, where any properties that are functions\n     * have been run to produce a result.\n     */\n\n  }, {\n    key: \"mergedSchema\",\n    value: function mergedSchema() {\n      var _this2 = this;\n\n      var mergedSchema = {};\n\n      this._schemaKeys.forEach(function (key) {\n        var keySchema = _this2._schema[key];\n        mergedSchema[key] = keySchema;\n        keySchema.type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          var childSchema = typeDef.type.mergedSchema();\n          Object.keys(childSchema).forEach(function (subKey) {\n            mergedSchema[\"\".concat(key, \".\").concat(subKey)] = childSchema[subKey];\n          });\n        });\n      });\n\n      return mergedSchema;\n    }\n    /**\n     * Returns the evaluated definition for one key in the schema\n     *\n     * @param {String} key Generic or specific schema key\n     * @param {Array(String)} [propList] Array of schema properties you need; performance optimization\n     * @param {Object} [functionContext] The context to use when evaluating schema options that are functions\n     * @returns {Object} The schema definition for the requested key\n     */\n\n  }, {\n    key: \"getDefinition\",\n    value: function getDefinition(key, propList) {\n      var _this3 = this;\n\n      var functionContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var defs = this.schema(key);\n      if (!defs) return;\n\n      var getPropIterator = function getPropIterator(obj, newObj) {\n        return function (prop) {\n          if (Array.isArray(propList) && !(0, _lodash2[\"default\"])(propList, prop)) return;\n          var val = obj[prop]; // For any options that support specifying a function, evaluate the functions\n\n          if (propsThatCanBeFunction.indexOf(prop) > -1 && typeof val === 'function') {\n            newObj[prop] = val.call(_objectSpread({\n              key: key\n            }, functionContext)); // Inflect label if undefined\n\n            if (prop === 'label' && typeof newObj[prop] !== 'string') newObj[prop] = inflectedLabel(key, _this3._constructorOptions.humanizeAutoLabels);\n          } else {\n            newObj[prop] = val;\n          }\n        };\n      };\n\n      var result = {};\n      Object.keys(defs).forEach(getPropIterator(defs, result)); // Resolve all the types and convert to a normal array to make it easier\n      // to use.\n\n      if (defs.type) {\n        result.type = defs.type.definitions.map(function (typeDef) {\n          var newTypeDef = {};\n          Object.keys(typeDef).forEach(getPropIterator(typeDef, newTypeDef));\n          return newTypeDef;\n        });\n      }\n\n      return result;\n    }\n    /**\n     * Returns a string identifying the best guess data type for a key. For keys\n     * that allow multiple types, the first type is used. This can be useful for\n     * building forms.\n     *\n     * @param {String} key Generic or specific schema key\n     * @returns {String} A type string. One of:\n     *  string, number, boolean, date, object, stringArray, numberArray, booleanArray,\n     *  dateArray, objectArray\n     */\n\n  }, {\n    key: \"getQuickTypeForKey\",\n    value: function getQuickTypeForKey(key) {\n      var type;\n      var fieldSchema = this.schema(key);\n      if (!fieldSchema) return;\n      var fieldType = fieldSchema.type.singleType;\n\n      if (fieldType === String) {\n        type = 'string';\n      } else if (fieldType === Number || fieldType === SimpleSchema.Integer) {\n        type = 'number';\n      } else if (fieldType === Boolean) {\n        type = 'boolean';\n      } else if (fieldType === Date) {\n        type = 'date';\n      } else if (fieldType === Array) {\n        var arrayItemFieldSchema = this.schema(\"\".concat(key, \".$\"));\n        if (!arrayItemFieldSchema) return;\n        var arrayItemFieldType = arrayItemFieldSchema.type.singleType;\n\n        if (arrayItemFieldType === String) {\n          type = 'stringArray';\n        } else if (arrayItemFieldType === Number || arrayItemFieldType === SimpleSchema.Integer) {\n          type = 'numberArray';\n        } else if (arrayItemFieldType === Boolean) {\n          type = 'booleanArray';\n        } else if (arrayItemFieldType === Date) {\n          type = 'dateArray';\n        } else if (arrayItemFieldType === Object || SimpleSchema.isSimpleSchema(arrayItemFieldType)) {\n          type = 'objectArray';\n        }\n      } else if (fieldType === Object) {\n        type = 'object';\n      }\n\n      return type;\n    }\n    /**\n     * Given a key that is an Object, returns a new SimpleSchema instance scoped to that object.\n     *\n     * @param {String} key Generic or specific schema key\n     */\n\n  }, {\n    key: \"getObjectSchema\",\n    value: function getObjectSchema(key) {\n      var newSchemaDef = {};\n\n      var genericKey = _mongoObject[\"default\"].makeKeyGeneric(key);\n\n      var searchString = \"\".concat(genericKey, \".\");\n      var mergedSchema = this.mergedSchema();\n      Object.keys(mergedSchema).forEach(function (k) {\n        if (k.indexOf(searchString) === 0) {\n          newSchemaDef[k.slice(searchString.length)] = mergedSchema[k];\n        }\n      });\n      return this._copyWithSchema(newSchemaDef);\n    } // Returns an array of all the autovalue functions, including those in subschemas all the\n    // way down the schema tree\n\n  }, {\n    key: \"autoValueFunctions\",\n    value: function autoValueFunctions() {\n      var _this4 = this;\n\n      var result = [].concat(this._autoValues);\n\n      this._schemaKeys.forEach(function (key) {\n        _this4._schema[key].type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          result = result.concat(typeDef.type.autoValueFunctions().map(function (_ref2) {\n            var func = _ref2.func,\n                fieldName = _ref2.fieldName,\n                closestSubschemaFieldName = _ref2.closestSubschemaFieldName;\n            return {\n              func: func,\n              fieldName: \"\".concat(key, \".\").concat(fieldName),\n              closestSubschemaFieldName: closestSubschemaFieldName.length ? \"\".concat(key, \".\").concat(closestSubschemaFieldName) : key\n            };\n          }));\n        });\n      });\n\n      return result;\n    } // Returns an array of all the blackbox keys, including those in subschemas\n\n  }, {\n    key: \"blackboxKeys\",\n    value: function blackboxKeys() {\n      var _this5 = this;\n\n      var blackboxKeys = this._blackboxKeys;\n\n      this._schemaKeys.forEach(function (key) {\n        _this5._schema[key].type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n\n          typeDef.type._blackboxKeys.forEach(function (blackboxKey) {\n            blackboxKeys.push(\"\".concat(key, \".\").concat(blackboxKey));\n          });\n        });\n      });\n\n      return (0, _lodash6[\"default\"])(blackboxKeys);\n    } // Check if the key is a nested dot-syntax key inside of a blackbox object\n\n  }, {\n    key: \"keyIsInBlackBox\",\n    value: function keyIsInBlackBox(key) {\n      var _this6 = this;\n\n      var isInBlackBox = false;\n      (0, _utility.forEachKeyAncestor)(_mongoObject[\"default\"].makeKeyGeneric(key), function (ancestor, remainder) {\n        if (_this6._blackboxKeys.indexOf(ancestor) > -1) {\n          isInBlackBox = true;\n        } else {\n          var testKeySchema = _this6.schema(ancestor);\n\n          if (testKeySchema) {\n            testKeySchema.type.definitions.forEach(function (typeDef) {\n              if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n              if (typeDef.type.keyIsInBlackBox(remainder)) isInBlackBox = true;\n            });\n          }\n        }\n      });\n      return isInBlackBox;\n    } // Returns true if key is explicitly allowed by the schema or implied\n    // by other explicitly allowed keys.\n    // The key string should have $ in place of any numeric array positions.\n\n  }, {\n    key: \"allowsKey\",\n    value: function allowsKey(key) {\n      var _this7 = this; // Loop through all keys in the schema\n\n\n      return this._schemaKeys.some(function (loopKey) {\n        // If the schema key is the test key, it's allowed.\n        if (loopKey === key) return true;\n\n        var fieldSchema = _this7.schema(loopKey);\n\n        var compare1 = key.slice(0, loopKey.length + 2);\n        var compare2 = compare1.slice(0, -1); // Blackbox and subschema checks are needed only if key starts with\n        // loopKey + a dot\n\n        if (compare2 !== \"\".concat(loopKey, \".\")) return false; // Black box handling\n\n        if (_this7._blackboxKeys.indexOf(loopKey) > -1) {\n          // If the test key is the black box key + \".$\", then the test\n          // key is NOT allowed because black box keys are by definition\n          // only for objects, and not for arrays.\n          return compare1 !== \"\".concat(loopKey, \".$\");\n        } // Subschemas\n\n\n        var allowed = false;\n        var subKey = key.slice(loopKey.length + 1);\n        fieldSchema.type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          if (typeDef.type.allowsKey(subKey)) allowed = true;\n        });\n        return allowed;\n      });\n    }\n    /**\n     * Returns all the child keys for the object identified by the generic prefix,\n     * or all the top level keys if no prefix is supplied.\n     *\n     * @param {String} [keyPrefix] The Object-type generic key for which to get child keys. Omit for\n     *   top-level Object-type keys\n     * @returns {[[Type]]} [[Description]]\n     */\n\n  }, {\n    key: \"objectKeys\",\n    value: function objectKeys(keyPrefix) {\n      if (!keyPrefix) return this._firstLevelSchemaKeys;\n      return this._objectKeys[\"\".concat(keyPrefix, \".\")] || [];\n    }\n    /**\n     * Copies this schema into a new instance with the same validators, messages,\n     * and options, but with different keys as defined in `schema` argument\n     *\n     * @param {Object} schema\n     * @returns The new SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: \"_copyWithSchema\",\n    value: function _copyWithSchema(schema) {\n      var cl = new SimpleSchema(schema, (0, _clone[\"default\"])(this._constructorOptions, false, 1));\n      cl._cleanOptions = this._cleanOptions;\n      cl.messageBox = this.messageBox.clone();\n      return cl;\n    }\n    /**\n     * Clones this schema into a new instance with the same schema keys, validators,\n     * and options.\n     *\n     * @returns The new SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return this._copyWithSchema(this._schema);\n    }\n    /**\n     * Extends (mutates) this schema with another schema, key by key.\n     *\n     * @param {SimpleSchema|Object} schema\n     * @returns The SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: \"extend\",\n    value: function extend() {\n      var _this8 = this;\n\n      var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (Array.isArray(schema)) throw new Error('You may not pass an array of schemas to the SimpleSchema constructor or to extend()');\n      var schemaObj;\n\n      if (SimpleSchema.isSimpleSchema(schema)) {\n        schemaObj = schema._schema;\n        this._validators = this._validators.concat(schema._validators);\n        this._docValidators = this._docValidators.concat(schema._docValidators);\n        this._cleanOptions = (0, _extend2[\"default\"])(false, this._cleanOptions, schema._cleanOptions);\n        this._constructorOptions = (0, _extend2[\"default\"])(false, this._constructorOptions, schema._constructorOptions);\n      } else {\n        schemaObj = (0, _expandShorthand[\"default\"])(schema);\n      } // Update all of the information cached on the instance\n\n\n      Object.keys(schemaObj).forEach(function (fieldName) {\n        var definition = standardizeDefinition(schemaObj[fieldName]); // Merge/extend with any existing definition\n\n        if (_this8._schema[fieldName]) {\n          if (!_this8._schema.hasOwnProperty(fieldName)) {\n            // fieldName is actually a method from Object itself!\n            throw new Error(\"\".concat(fieldName, \" key is actually the name of a method on Object, please rename it\"));\n          }\n\n          _this8._schema[fieldName] = _objectSpread({}, _this8._schema[fieldName], {}, (0, _lodash4[\"default\"])(definition, 'type'));\n          if (definition.type) _this8._schema[fieldName].type.extend(definition.type);\n        } else {\n          _this8._schema[fieldName] = definition;\n        }\n\n        checkAndScrubDefinition(fieldName, _this8._schema[fieldName], _this8._constructorOptions, schemaObj);\n      });\n      checkSchemaOverlap(this._schema); // Set/Reset all of these\n\n      this._schemaKeys = Object.keys(this._schema);\n      this._autoValues = [];\n      this._blackboxKeys = [];\n      this._firstLevelSchemaKeys = [];\n      this._objectKeys = {}; // Update all of the information cached on the instance\n\n      this._schemaKeys.forEach(function (fieldName) {\n        // Make sure parent has a definition in the schema. No implied objects!\n        if (fieldName.indexOf('.') > -1) {\n          var parentFieldName = fieldName.slice(0, fieldName.lastIndexOf('.'));\n          if (!_this8._schema.hasOwnProperty(parentFieldName)) throw new Error(\"\\\"\".concat(fieldName, \"\\\" is in the schema but \\\"\").concat(parentFieldName, \"\\\" is not\"));\n        }\n\n        var definition = _this8._schema[fieldName]; // Keep list of all top level keys\n\n        if (fieldName.indexOf('.') === -1) _this8._firstLevelSchemaKeys.push(fieldName); // Keep list of all blackbox keys for passing to MongoObject constructor\n        // XXX For now if any oneOf type is blackbox, then the whole field is.\n\n        (0, _lodash[\"default\"])(definition.type.definitions, function (oneOfDef) {\n          if (oneOfDef.blackbox === true) {\n            _this8._blackboxKeys.push(fieldName);\n\n            return false; // exit loop\n          }\n\n          return true;\n        }); // Keep list of autoValue functions\n\n        if (typeof definition.autoValue === 'function') {\n          _this8._autoValues.push({\n            closestSubschemaFieldName: '',\n            fieldName: fieldName,\n            func: definition.autoValue\n          });\n        }\n      }); // Store child keys keyed by parent. This needs to be done recursively to handle\n      // subschemas.\n\n\n      var setObjectKeys = function setObjectKeys(curSchema, schemaParentKey) {\n        Object.keys(curSchema).forEach(function (fieldName) {\n          var definition = curSchema[fieldName];\n          fieldName = schemaParentKey ? \"\".concat(schemaParentKey, \".\").concat(fieldName) : fieldName;\n\n          if (fieldName.indexOf('.') > -1 && fieldName.slice(-2) !== '.$') {\n            var parentKey = fieldName.slice(0, fieldName.lastIndexOf('.'));\n            var parentKeyWithDot = \"\".concat(parentKey, \".\");\n            _this8._objectKeys[parentKeyWithDot] = _this8._objectKeys[parentKeyWithDot] || [];\n\n            _this8._objectKeys[parentKeyWithDot].push(fieldName.slice(fieldName.lastIndexOf('.') + 1));\n          } // If the current field is a nested SimpleSchema,\n          // iterate over the child fields and cache their properties as well\n\n\n          definition.type.definitions.forEach(function (_ref3) {\n            var type = _ref3.type;\n\n            if (SimpleSchema.isSimpleSchema(type)) {\n              setObjectKeys(type._schema, fieldName);\n            }\n          });\n        });\n      };\n\n      setObjectKeys(this._schema);\n      return this;\n    }\n  }, {\n    key: \"getAllowedValuesForKey\",\n    value: function getAllowedValuesForKey(key) {\n      // For array fields, `allowedValues` is on the array item definition\n      if (this.allowsKey(\"\".concat(key, \".$\"))) {\n        key = \"\".concat(key, \".$\");\n      }\n\n      var allowedValues = this.get(key, 'allowedValues');\n      return (0, _lodash3[\"default\"])(allowedValues) ? null : _toConsumableArray(allowedValues);\n    }\n  }, {\n    key: \"newContext\",\n    value: function newContext() {\n      return new _ValidationContext[\"default\"](this);\n    }\n  }, {\n    key: \"namedContext\",\n    value: function namedContext(name) {\n      if (typeof name !== 'string') name = 'default';\n\n      if (!this._validationContexts[name]) {\n        this._validationContexts[name] = new _ValidationContext[\"default\"](this);\n      }\n\n      return this._validationContexts[name];\n    }\n  }, {\n    key: \"addValidator\",\n    value: function addValidator(func) {\n      this._validators.push(func);\n    }\n  }, {\n    key: \"addDocValidator\",\n    value: function addDocValidator(func) {\n      this._docValidators.push(func);\n    }\n    /**\n     * @param obj {Object|Object[]} Object or array of objects to validate.\n     * @param [options] {Object} Same options object that ValidationContext#validate takes\n     *\n     * Throws an Error with name `ClientError` and `details` property containing the errors.\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate(obj) {\n      var _this9 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // For Meteor apps, `check` option can be passed to silence audit-argument-checks\n\n      var check = options.check || this._constructorOptions.check;\n\n      if (typeof check === 'function') {\n        // Call check but ignore the error\n        try {\n          check(obj);\n        } catch (e) {\n          /* ignore error */\n        }\n      } // obj can be an array, in which case we validate each object in it and\n      // throw as soon as one has an error\n\n\n      var objects = Array.isArray(obj) ? obj : [obj];\n      objects.forEach(function (oneObj) {\n        var validationContext = _this9.newContext();\n\n        var isValid = validationContext.validate(oneObj, options);\n        if (isValid) return;\n        var errors = validationContext.validationErrors(); // In order for the message at the top of the stack trace to be useful,\n        // we set it to the first validation error message.\n\n        var message = _this9.messageForError(errors[0]);\n\n        var error = new Error(message);\n        error.name = error.errorType = 'ClientError';\n        error.error = 'validation-error'; // Add meaningful error messages for each validation error.\n        // Useful for display messages when using 'mdg:validated-method'.\n\n        error.details = errors.map(function (errorDetail) {\n          return _objectSpread({}, errorDetail, {\n            message: _this9.messageForError(errorDetail)\n          });\n        }); // The primary use for the validationErrorTransform is to convert the\n        // vanilla Error into a Meteor.Error until DDP is able to pass\n        // vanilla errors back to the client.\n\n        if (typeof SimpleSchema.validationErrorTransform === 'function') {\n          throw SimpleSchema.validationErrorTransform(error);\n        } else {\n          throw error;\n        }\n      });\n    }\n    /**\n     * @param obj {Object} Object to validate.\n     * @param [options] {Object} Same options object that ValidationContext#validate takes\n     *\n     * Returns a Promise that resolves with the errors\n     */\n\n  }, {\n    key: \"validateAndReturnErrorsPromise\",\n    value: function validateAndReturnErrorsPromise(obj, options) {\n      var _this10 = this;\n\n      var validationContext = this.newContext();\n      var isValid = validationContext.validate(obj, options);\n      if (isValid) return Promise.resolve([]); // Add the `message` prop\n\n      var errors = validationContext.validationErrors().map(function (errorDetail) {\n        return _objectSpread({}, errorDetail, {\n          message: _this10.messageForError(errorDetail)\n        });\n      });\n      return Promise.resolve(errors);\n    }\n  }, {\n    key: \"validator\",\n    value: function validator() {\n      var _this11 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return function (obj) {\n        var optionsClone = _objectSpread({}, options);\n\n        if (options.clean === true) {\n          // Do this here and pass into both functions for better performance\n          optionsClone.mongoObject = new _mongoObject[\"default\"](obj, _this11.blackboxKeys());\n\n          _this11.clean(obj, optionsClone);\n        }\n\n        if (options.returnErrorsPromise) {\n          return _this11.validateAndReturnErrorsPromise(obj, optionsClone);\n        }\n\n        return _this11.validate(obj, optionsClone);\n      };\n    }\n  }, {\n    key: \"getFormValidator\",\n    value: function getFormValidator() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.validator(_objectSpread({}, options, {\n        returnErrorsPromise: true\n      }));\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _clean2[\"default\"].apply(void 0, [this].concat(args));\n    }\n    /**\n     * Change schema labels on the fly, causing mySchema.label computation\n     * to rerun. Useful when the user changes the language.\n     *\n     * @param {Object} labels A dictionary of all the new label values, by schema key.\n     */\n\n  }, {\n    key: \"labels\",\n    value: function labels(_labels) {\n      var _this12 = this;\n\n      Object.keys(_labels).forEach(function (key) {\n        var label = _labels[key];\n        if (typeof label !== 'string' && typeof label !== 'function') return;\n        if (!_this12._schema.hasOwnProperty(key)) return;\n        _this12._schema[key].label = label;\n        _this12._depsLabels[key] && _this12._depsLabels[key].changed();\n      });\n    }\n    /**\n     * Gets a field's label or all field labels reactively.\n     *\n     * @param {String} [key] The schema key, specific or generic.\n     *   Omit this argument to get a dictionary of all labels.\n     * @returns {String} The label\n     */\n\n  }, {\n    key: \"label\",\n    value: function label(key) {\n      var _this13 = this; // Get all labels\n\n\n      if (key === null || key === undefined) {\n        var result = {};\n\n        this._schemaKeys.forEach(function (schemaKey) {\n          result[schemaKey] = _this13.label(schemaKey);\n        });\n\n        return result;\n      } // Get label for one field\n\n\n      var label = this.get(key, 'label');\n      if (label) this.reactiveLabelDependency(key);\n      return label || null;\n    }\n    /**\n     * Gets a field's property\n     *\n     * @param {String} key The schema key, specific or generic.\n     * @param {String} prop Name of the property to get for that schema key\n     * @param {Object} [functionContext] The `this` context to use if prop is a function\n     * @returns {any} The property value\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, prop, functionContext) {\n      var def = this.getDefinition(key, ['type', prop], functionContext);\n      if (!def) return undefined;\n\n      if ((0, _lodash2[\"default\"])(schemaDefinitionOptions, prop)) {\n        return def[prop];\n      }\n\n      return (def.type.find(function (props) {\n        return props[prop];\n      }) || {})[prop];\n    } // shorthand for getting defaultValue\n\n  }, {\n    key: \"defaultValue\",\n    value: function defaultValue(key) {\n      return this.get(key, 'defaultValue');\n    } // Returns a string message for the given error type and key. Passes through\n    // to message-box pkg.\n\n  }, {\n    key: \"messageForError\",\n    value: function messageForError(errorInfo) {\n      var name = errorInfo.name;\n      return this.messageBox.message(errorInfo, {\n        context: {\n          key: name,\n          // backward compatibility\n          // The call to this.label() establishes a reactive dependency, too\n          label: this.label(name)\n        }\n      });\n    }\n    /**\n     * @method SimpleSchema#pick\n     * @param {[fields]} The list of fields to pick to instantiate the subschema\n     * @returns {SimpleSchema} The subschema\n     */\n\n  }], [{\n    key: \"isSimpleSchema\",\n    value: function isSimpleSchema(obj) {\n      return obj && (obj instanceof SimpleSchema || obj._schema);\n    }\n  }, {\n    key: \"extendOptions\",\n    // If you need to allow properties other than those listed above, call this from your app or package\n    value: function extendOptions(options) {\n      // For backwards compatibility we still take an object here, but we only care about the names\n      if (!Array.isArray(options)) options = Object.keys(options);\n      options.forEach(function (option) {\n        schemaDefinitionOptions.push(option);\n      });\n    }\n  }, {\n    key: \"defineValidationErrorTransform\",\n    value: function defineValidationErrorTransform(transform) {\n      if (typeof transform !== 'function') {\n        throw new Error('SimpleSchema.defineValidationErrorTransform must be passed a function that accepts an Error and returns an Error');\n      }\n\n      SimpleSchema.validationErrorTransform = transform;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(obj, schema, options) {\n      // Allow passing just the schema object\n      if (!SimpleSchema.isSimpleSchema(schema)) {\n        schema = new SimpleSchema(schema);\n      }\n\n      return schema.validate(obj, options);\n    }\n  }, {\n    key: \"oneOf\",\n    value: function oneOf() {\n      for (var _len2 = arguments.length, definitions = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        definitions[_key2] = arguments[_key2];\n      }\n\n      return _construct(_SimpleSchemaGroup[\"default\"], definitions);\n    }\n  }, {\n    key: \"addValidator\",\n    value: function addValidator(func) {\n      SimpleSchema._validators.push(func);\n    }\n  }, {\n    key: \"addDocValidator\",\n    value: function addDocValidator(func) {\n      SimpleSchema._docValidators.push(func);\n    }\n  }]);\n\n  return SimpleSchema;\n}();\n/*\n * PRIVATE\n */\n// Throws an error if any fields are `type` SimpleSchema but then also\n// have subfields defined outside of that.\n\n\nexports.SimpleSchema = SimpleSchema;\n\n_defineProperty(SimpleSchema, \"version\", 2);\n\n_defineProperty(SimpleSchema, \"RegEx\", _regExp[\"default\"]);\n\n_defineProperty(SimpleSchema, \"_validators\", []);\n\n_defineProperty(SimpleSchema, \"_docValidators\", []);\n\n_defineProperty(SimpleSchema, \"ErrorTypes\", {\n  REQUIRED: 'required',\n  MIN_STRING: 'minString',\n  MAX_STRING: 'maxString',\n  MIN_NUMBER: 'minNumber',\n  MAX_NUMBER: 'maxNumber',\n  MIN_NUMBER_EXCLUSIVE: 'minNumberExclusive',\n  MAX_NUMBER_EXCLUSIVE: 'maxNumberExclusive',\n  MIN_DATE: 'minDate',\n  MAX_DATE: 'maxDate',\n  BAD_DATE: 'badDate',\n  MIN_COUNT: 'minCount',\n  MAX_COUNT: 'maxCount',\n  MUST_BE_INTEGER: 'noDecimal',\n  VALUE_NOT_ALLOWED: 'notAllowed',\n  EXPECTED_TYPE: 'expectedType',\n  FAILED_REGULAR_EXPRESSION: 'regEx',\n  KEY_NOT_IN_SCHEMA: 'keyNotInSchema'\n});\n\n_defineProperty(SimpleSchema, \"Integer\", 'SimpleSchema.Integer');\n\n_defineProperty(SimpleSchema, \"_makeGeneric\", _mongoObject[\"default\"].makeKeyGeneric);\n\n_defineProperty(SimpleSchema, \"ValidationContext\", _ValidationContext[\"default\"]);\n\n_defineProperty(SimpleSchema, \"setDefaultMessages\", function (messages) {\n  (0, _extend2[\"default\"])(true, _defaultMessages[\"default\"], messages);\n});\n\nfunction checkSchemaOverlap(schema) {\n  Object.keys(schema).forEach(function (key) {\n    var val = schema[key];\n    if (!val.type) throw new Error(\"\".concat(key, \" key is missing \\\"type\\\"\"));\n    val.type.definitions.forEach(function (def) {\n      if (!SimpleSchema.isSimpleSchema(def.type)) return;\n      Object.keys(def.type._schema).forEach(function (subKey) {\n        var newKey = \"\".concat(key, \".\").concat(subKey);\n\n        if (schema.hasOwnProperty(newKey)) {\n          throw new Error(\"The type for \\\"\".concat(key, \"\\\" is set to a SimpleSchema instance that defines \\\"\").concat(key, \".\").concat(subKey, \"\\\", but the parent SimpleSchema instance also tries to define \\\"\").concat(key, \".\").concat(subKey, \"\\\"\"));\n        }\n      });\n    });\n  });\n}\n/**\n * @param {String} fieldName The full generic schema key\n * @param {Boolean} shouldHumanize Humanize it\n * @returns {String} A label based on the key\n */\n\n\nfunction inflectedLabel(fieldName, shouldHumanize) {\n  var pieces = fieldName.split('.');\n  var label;\n\n  do {\n    label = pieces.pop();\n  } while (label === '$' && pieces.length);\n\n  return shouldHumanize ? (0, _humanize[\"default\"])(label) : label;\n}\n\nfunction getDefaultAutoValueFunction(defaultValue) {\n  return function defaultAutoValueFunction() {\n    if (this.isSet) return;\n    if (this.operator === null) return defaultValue; // Handle the case when pulling an object from an array the object contains a field\n    // which has a defaultValue. We don't want the default value to be returned in this case\n\n    if (this.operator === '$pull') return; // Handle the case where we are $pushing an object into an array of objects and we\n    // want any fields missing from that object to be added if they have default values\n\n    if (this.operator === '$push') return defaultValue; // If parent is set, we should update this position instead of $setOnInsert\n\n    if (this.parentField().isSet) return defaultValue; // Make sure the default value is added on upsert insert\n\n    if (this.isUpsert) return {\n      $setOnInsert: defaultValue\n    };\n  };\n} // Mutates def into standardized object with SimpleSchemaGroup type\n\n\nfunction standardizeDefinition(def) {\n  var standardizedDef = (0, _lodash4[\"default\"])(def, oneOfProps); // Internally, all definition types are stored as groups for simplicity of access.\n  // If we are extending, there may not actually be def.type, but it's okay because\n  // it will be added later when the two SimpleSchemaGroups are merged.\n\n  if (def.type && def.type instanceof _SimpleSchemaGroup[\"default\"]) {\n    standardizedDef.type = def.type.clone();\n  } else {\n    var groupProps = (0, _lodash5[\"default\"])(def, oneOfProps);\n    standardizedDef.type = new _SimpleSchemaGroup[\"default\"](groupProps);\n  }\n\n  return standardizedDef;\n} // Checks and mutates definition. Clone it first.\n\n\nfunction checkAndScrubDefinition(fieldName, definition, options, fullSchemaObj) {\n  if (!definition.type) throw new Error(\"\".concat(fieldName, \" key is missing \\\"type\\\"\")); // Validate the field definition\n\n  Object.keys(definition).forEach(function (key) {\n    if (schemaDefinitionOptions.indexOf(key) === -1) {\n      throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"\").concat(key, \"\\\" is not a supported property\"));\n    }\n  }); // Make sure the `type`s are OK\n\n  var couldBeArray = false;\n  definition.type.definitions.forEach(function (_ref4) {\n    var type = _ref4.type;\n    if (!type) throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"type\\\" option is required\"));\n\n    if (Array.isArray(type)) {\n      throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"type\\\" may not be an array. Change it to Array.\"));\n    }\n\n    if (type.constructor === Object && (0, _lodash3[\"default\"])(type)) {\n      throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"type\\\" may not be an object. Change it to Object\"));\n    }\n\n    if (type === Array) couldBeArray = true;\n\n    if (SimpleSchema.isSimpleSchema(type)) {\n      Object.keys(type._schema).forEach(function (subKey) {\n        var newKey = \"\".concat(fieldName, \".\").concat(subKey);\n\n        if (fullSchemaObj.hasOwnProperty(newKey)) {\n          throw new Error(\"The type for \\\"\".concat(fieldName, \"\\\" is set to a SimpleSchema instance that defines \\\"\").concat(newKey, \"\\\", but the parent SimpleSchema instance also tries to define \\\"\").concat(newKey, \"\\\"\"));\n        }\n      });\n    }\n  }); // If at least one of the possible types is Array, then make sure we have a\n  // definition for the array items, too.\n\n  if (couldBeArray && !fullSchemaObj.hasOwnProperty(\"\".concat(fieldName, \".$\"))) {\n    throw new Error(\"\\\"\".concat(fieldName, \"\\\" is Array type but the schema does not include a \\\"\").concat(fieldName, \".$\\\" definition for the array items\\\"\"));\n  } // defaultValue -> autoValue\n  // We support defaultValue shortcut by converting it immediately into an\n  // autoValue.\n\n\n  if ('defaultValue' in definition) {\n    if ('autoValue' in definition && !definition.autoValue.isDefault) {\n      console.warn(\"SimpleSchema: Found both autoValue and defaultValue options for \\\"\".concat(fieldName, \"\\\". Ignoring defaultValue.\"));\n    } else {\n      if (fieldName.endsWith('.$')) {\n        throw new Error('An array item field (one that ends with \".$\") cannot have defaultValue.');\n      }\n\n      definition.autoValue = getDefaultAutoValueFunction(definition.defaultValue);\n      definition.autoValue.isDefault = true;\n    }\n  } // REQUIREDNESS\n\n\n  if (fieldName.endsWith('.$')) {\n    definition.optional = true;\n  } else {\n    if (!definition.hasOwnProperty('optional')) {\n      if (definition.hasOwnProperty('required')) {\n        if (typeof definition.required === 'function') {\n          definition.optional = function optional() {\n            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n              args[_key3] = arguments[_key3];\n            }\n\n            return !definition.required.apply(this, args);\n          };\n        } else {\n          definition.optional = !definition.required;\n        }\n      } else {\n        definition.optional = options.requiredByDefault === false;\n      }\n    }\n  }\n\n  delete definition.required; // LABELS\n\n  if (!definition.hasOwnProperty('label')) {\n    if (options.defaultLabel) {\n      definition.label = options.defaultLabel;\n    } else if (SimpleSchema.defaultLabel) {\n      definition.label = SimpleSchema.defaultLabel;\n    } else {\n      definition.label = inflectedLabel(fieldName, options.humanizeAutoLabels);\n    }\n  }\n}\n\nfunction getPickOrOmit(type) {\n  return function pickOrOmit() {\n    var _this14 = this;\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    } // If they are picking/omitting an object or array field, we need to also include everything under it\n\n\n    var newSchema = {};\n\n    this._schemaKeys.forEach(function (key) {\n      // Pick/omit it if it IS in the array of keys they want OR if it\n      // STARTS WITH something that is in the array plus a period\n      var includeIt = args.some(function (wantedField) {\n        return key === wantedField || key.indexOf(\"\".concat(wantedField, \".\")) === 0;\n      });\n\n      if (includeIt && type === 'pick' || !includeIt && type === 'omit') {\n        newSchema[key] = _this14._schema[key];\n      }\n    });\n\n    return this._copyWithSchema(newSchema);\n  };\n}","map":{"version":3,"sources":["C:/Users/asus/Desktop/new template/myadmin-lite/node_modules/simpl-schema/dist/SimpleSchema.js"],"names":["Object","defineProperty","exports","value","enumerable","get","_ValidationContext","SimpleSchema","schemaDefinitionOptions","_clone","_interopRequireDefault","require","_lodash","_extend2","_lodash2","_lodash3","_messageBox","_mongoObject","_lodash4","_lodash5","_lodash6","_humanize","_SimpleSchemaGroup","_regExp","_clean2","_expandShorthand","_utility","_defaultMessages","obj","__esModule","isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","prototype","toString","call","e","_construct","Parent","args","Class","a","push","apply","Constructor","Function","bind","instance","_setPrototypeOf","arguments","o","p","setPrototypeOf","__proto__","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Array","from","isArray","i","arr2","length","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","_objectSpread","target","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","_classCallCheck","_defineProperties","props","descriptor","configurable","writable","_createClass","protoProps","staticProps","oneOfProps","propsThatCanBeFunction","schema","undefined","_ref","check","cleanOptions","clean","defaultLabel","_ref$humanizeAutoLabe","humanizeAutoLabels","_ref$requiredByDefaul","requiredByDefault","tracker","getPickOrOmit","_constructorOptions","_validators","_docValidators","_validationContexts","_cleanOptions","autoConvert","removeEmptyStrings","trimStrings","getAutoValues","removeNullsFromArrays","extendAutoValueContext","_schema","_depsLabels","extend","messageBox","version","forEachAncestorSimpleSchema","func","_this","genericKey","makeKeyGeneric","forEachKeyAncestor","ancestor","def","type","definitions","typeDef","isSimpleSchema","slice","reactiveLabelDependency","Dependency","depend","simpleSchema","subSchemaKey","keySchema","found","mergedSchema","_this2","_schemaKeys","childSchema","subKey","concat","getDefinition","propList","_this3","functionContext","defs","getPropIterator","newObj","prop","val","indexOf","inflectedLabel","result","map","newTypeDef","getQuickTypeForKey","fieldSchema","fieldType","singleType","String","Number","Integer","Boolean","arrayItemFieldSchema","arrayItemFieldType","getObjectSchema","newSchemaDef","searchString","k","_copyWithSchema","autoValueFunctions","_this4","_autoValues","_ref2","fieldName","closestSubschemaFieldName","blackboxKeys","_this5","_blackboxKeys","blackboxKey","keyIsInBlackBox","_this6","isInBlackBox","remainder","testKeySchema","allowsKey","_this7","some","loopKey","compare1","compare2","allowed","objectKeys","keyPrefix","_firstLevelSchemaKeys","_objectKeys","cl","clone","_this8","Error","schemaObj","definition","standardizeDefinition","hasOwnProperty","checkAndScrubDefinition","checkSchemaOverlap","parentFieldName","lastIndexOf","oneOfDef","blackbox","autoValue","setObjectKeys","curSchema","schemaParentKey","parentKey","parentKeyWithDot","_ref3","getAllowedValuesForKey","allowedValues","newContext","namedContext","name","addValidator","addDocValidator","validate","_this9","options","objects","oneObj","validationContext","isValid","errors","validationErrors","message","messageForError","error","errorType","details","errorDetail","validationErrorTransform","validateAndReturnErrorsPromise","_this10","Promise","resolve","validator","_this11","optionsClone","mongoObject","returnErrorsPromise","getFormValidator","_len","_key","labels","_labels","_this12","label","changed","_this13","schemaKey","find","defaultValue","errorInfo","context","extendOptions","option","defineValidationErrorTransform","transform","oneOf","_len2","_key2","REQUIRED","MIN_STRING","MAX_STRING","MIN_NUMBER","MAX_NUMBER","MIN_NUMBER_EXCLUSIVE","MAX_NUMBER_EXCLUSIVE","MIN_DATE","MAX_DATE","BAD_DATE","MIN_COUNT","MAX_COUNT","MUST_BE_INTEGER","VALUE_NOT_ALLOWED","EXPECTED_TYPE","FAILED_REGULAR_EXPRESSION","KEY_NOT_IN_SCHEMA","messages","newKey","shouldHumanize","pieces","split","pop","getDefaultAutoValueFunction","defaultAutoValueFunction","isSet","operator","parentField","isUpsert","$setOnInsert","standardizedDef","groupProps","fullSchemaObj","couldBeArray","_ref4","constructor","isDefault","console","warn","endsWith","optional","required","_len3","_key3","pickOrOmit","_this14","_len4","_key4","newSchema","includeIt","wantedField"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"ValidationContext\", {\n  enumerable: true,\n  get: function get() {\n    return _ValidationContext[\"default\"];\n  }\n});\nexports.SimpleSchema = exports.schemaDefinitionOptions = void 0;\n\nvar _clone = _interopRequireDefault(require(\"clone\"));\n\nvar _lodash = _interopRequireDefault(require(\"lodash.every\"));\n\nvar _extend2 = _interopRequireDefault(require(\"extend\"));\n\nvar _lodash2 = _interopRequireDefault(require(\"lodash.includes\"));\n\nvar _lodash3 = _interopRequireDefault(require(\"lodash.isempty\"));\n\nvar _messageBox = _interopRequireDefault(require(\"message-box\"));\n\nvar _mongoObject = _interopRequireDefault(require(\"mongo-object\"));\n\nvar _lodash4 = _interopRequireDefault(require(\"lodash.omit\"));\n\nvar _lodash5 = _interopRequireDefault(require(\"lodash.pick\"));\n\nvar _lodash6 = _interopRequireDefault(require(\"lodash.uniq\"));\n\nvar _humanize = _interopRequireDefault(require(\"./humanize.js\"));\n\nvar _ValidationContext = _interopRequireDefault(require(\"./ValidationContext\"));\n\nvar _SimpleSchemaGroup = _interopRequireDefault(require(\"./SimpleSchemaGroup\"));\n\nvar _regExp = _interopRequireDefault(require(\"./regExp\"));\n\nvar _clean2 = _interopRequireDefault(require(\"./clean\"));\n\nvar _expandShorthand = _interopRequireDefault(require(\"./expandShorthand\"));\n\nvar _utility = require(\"./utility\");\n\nvar _defaultMessages = _interopRequireDefault(require(\"./defaultMessages\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// Exported for tests\nvar schemaDefinitionOptions = ['type', 'label', 'optional', 'required', 'autoValue', 'defaultValue'];\nexports.schemaDefinitionOptions = schemaDefinitionOptions;\nvar oneOfProps = ['type', 'min', 'max', 'minCount', 'maxCount', 'allowedValues', 'exclusiveMin', 'exclusiveMax', 'regEx', 'custom', 'blackbox', 'trim'];\nvar propsThatCanBeFunction = ['label', 'optional', 'min', 'max', 'minCount', 'maxCount', 'allowedValues', 'exclusiveMin', 'exclusiveMax', 'regEx'];\n\nvar SimpleSchema =\n/*#__PURE__*/\nfunction () {\n  function SimpleSchema() {\n    var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        check = _ref.check,\n        cleanOptions = _ref.clean,\n        defaultLabel = _ref.defaultLabel,\n        _ref$humanizeAutoLabe = _ref.humanizeAutoLabels,\n        humanizeAutoLabels = _ref$humanizeAutoLabe === void 0 ? true : _ref$humanizeAutoLabe,\n        _ref$requiredByDefaul = _ref.requiredByDefault,\n        requiredByDefault = _ref$requiredByDefaul === void 0 ? true : _ref$requiredByDefaul,\n        tracker = _ref.tracker;\n\n    _classCallCheck(this, SimpleSchema);\n\n    _defineProperty(this, \"pick\", getPickOrOmit('pick'));\n\n    _defineProperty(this, \"omit\", getPickOrOmit('omit'));\n\n    // Stash the options object\n    this._constructorOptions = {\n      check: check,\n      defaultLabel: defaultLabel,\n      humanizeAutoLabels: humanizeAutoLabels,\n      requiredByDefault: requiredByDefault,\n      tracker: tracker\n    }; // Custom validators for this instance\n\n    this._validators = [];\n    this._docValidators = []; // Named validation contexts\n\n    this._validationContexts = {}; // Schema-level defaults for cleaning\n\n    this._cleanOptions = _objectSpread({\n      filter: true,\n      autoConvert: true,\n      removeEmptyStrings: true,\n      trimStrings: true,\n      getAutoValues: true,\n      removeNullsFromArrays: false,\n      extendAutoValueContext: {}\n    }, cleanOptions); // Clone, expanding shorthand, and store the schema object in this._schema\n\n    this._schema = {};\n    this._depsLabels = {};\n    this.extend(schema); // Define default validation error messages\n\n    this.messageBox = new _messageBox[\"default\"]((0, _clone[\"default\"])(_defaultMessages[\"default\"]));\n    this.version = SimpleSchema.version;\n  }\n\n  _createClass(SimpleSchema, [{\n    key: \"forEachAncestorSimpleSchema\",\n    value: function forEachAncestorSimpleSchema(key, func) {\n      var _this = this;\n\n      var genericKey = _mongoObject[\"default\"].makeKeyGeneric(key);\n\n      (0, _utility.forEachKeyAncestor)(genericKey, function (ancestor) {\n        var def = _this._schema[ancestor];\n        if (!def) return;\n        def.type.definitions.forEach(function (typeDef) {\n          if (SimpleSchema.isSimpleSchema(typeDef.type)) {\n            func(typeDef.type, ancestor, genericKey.slice(ancestor.length + 1));\n          }\n        });\n      });\n    }\n    /**\n     * Returns whether the obj is a SimpleSchema object.\n     * @param {Object} [obj] An object to test\n     * @returns {Boolean} True if the given object appears to be a SimpleSchema instance\n     */\n\n  }, {\n    key: \"reactiveLabelDependency\",\n\n    /**\n     * For Meteor apps, add a reactive dependency on the label\n     * for a key.\n     */\n    value: function reactiveLabelDependency(key) {\n      var tracker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._constructorOptions.tracker;\n      if (!key || !tracker) return;\n\n      var genericKey = _mongoObject[\"default\"].makeKeyGeneric(key); // If in this schema\n\n\n      if (this._schema[genericKey]) {\n        if (!this._depsLabels[genericKey]) {\n          this._depsLabels[genericKey] = new tracker.Dependency();\n        }\n\n        this._depsLabels[genericKey].depend();\n\n        return;\n      } // If in subschema\n\n\n      this.forEachAncestorSimpleSchema(key, function (simpleSchema, ancestor, subSchemaKey) {\n        // Pass tracker down so that we get reactivity even if the subschema\n        // didn't have tracker option set\n        simpleSchema.reactiveLabelDependency(subSchemaKey, tracker);\n      });\n    }\n    /**\n     * @param {String} [key] One specific or generic key for which to get the schema.\n     * @returns {Object} The entire schema object or just the definition for one key.\n     *\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\n     * if you want the evaluated definition, where any properties that are functions\n     * have been run to produce a result.\n     */\n\n  }, {\n    key: \"schema\",\n    value: function schema(key) {\n      if (!key) return this._schema;\n\n      var genericKey = _mongoObject[\"default\"].makeKeyGeneric(key);\n\n      var keySchema = this._schema[genericKey]; // If not defined in this schema, see if it's defined in a subschema\n\n      if (!keySchema) {\n        var found = false;\n        this.forEachAncestorSimpleSchema(key, function (simpleSchema, ancestor, subSchemaKey) {\n          if (!found) keySchema = simpleSchema.schema(subSchemaKey);\n          if (keySchema) found = true;\n        });\n      }\n\n      return keySchema;\n    }\n    /**\n     * @returns {Object} The entire schema object with subschemas merged. This is the\n     * equivalent of what schema() returned in SimpleSchema < 2.0\n     *\n     * Note that this returns the raw, unevaluated definition object. Use `getDefinition`\n     * if you want the evaluated definition, where any properties that are functions\n     * have been run to produce a result.\n     */\n\n  }, {\n    key: \"mergedSchema\",\n    value: function mergedSchema() {\n      var _this2 = this;\n\n      var mergedSchema = {};\n\n      this._schemaKeys.forEach(function (key) {\n        var keySchema = _this2._schema[key];\n        mergedSchema[key] = keySchema;\n        keySchema.type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          var childSchema = typeDef.type.mergedSchema();\n          Object.keys(childSchema).forEach(function (subKey) {\n            mergedSchema[\"\".concat(key, \".\").concat(subKey)] = childSchema[subKey];\n          });\n        });\n      });\n\n      return mergedSchema;\n    }\n    /**\n     * Returns the evaluated definition for one key in the schema\n     *\n     * @param {String} key Generic or specific schema key\n     * @param {Array(String)} [propList] Array of schema properties you need; performance optimization\n     * @param {Object} [functionContext] The context to use when evaluating schema options that are functions\n     * @returns {Object} The schema definition for the requested key\n     */\n\n  }, {\n    key: \"getDefinition\",\n    value: function getDefinition(key, propList) {\n      var _this3 = this;\n\n      var functionContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var defs = this.schema(key);\n      if (!defs) return;\n\n      var getPropIterator = function getPropIterator(obj, newObj) {\n        return function (prop) {\n          if (Array.isArray(propList) && !(0, _lodash2[\"default\"])(propList, prop)) return;\n          var val = obj[prop]; // For any options that support specifying a function, evaluate the functions\n\n          if (propsThatCanBeFunction.indexOf(prop) > -1 && typeof val === 'function') {\n            newObj[prop] = val.call(_objectSpread({\n              key: key\n            }, functionContext)); // Inflect label if undefined\n\n            if (prop === 'label' && typeof newObj[prop] !== 'string') newObj[prop] = inflectedLabel(key, _this3._constructorOptions.humanizeAutoLabels);\n          } else {\n            newObj[prop] = val;\n          }\n        };\n      };\n\n      var result = {};\n      Object.keys(defs).forEach(getPropIterator(defs, result)); // Resolve all the types and convert to a normal array to make it easier\n      // to use.\n\n      if (defs.type) {\n        result.type = defs.type.definitions.map(function (typeDef) {\n          var newTypeDef = {};\n          Object.keys(typeDef).forEach(getPropIterator(typeDef, newTypeDef));\n          return newTypeDef;\n        });\n      }\n\n      return result;\n    }\n    /**\n     * Returns a string identifying the best guess data type for a key. For keys\n     * that allow multiple types, the first type is used. This can be useful for\n     * building forms.\n     *\n     * @param {String} key Generic or specific schema key\n     * @returns {String} A type string. One of:\n     *  string, number, boolean, date, object, stringArray, numberArray, booleanArray,\n     *  dateArray, objectArray\n     */\n\n  }, {\n    key: \"getQuickTypeForKey\",\n    value: function getQuickTypeForKey(key) {\n      var type;\n      var fieldSchema = this.schema(key);\n      if (!fieldSchema) return;\n      var fieldType = fieldSchema.type.singleType;\n\n      if (fieldType === String) {\n        type = 'string';\n      } else if (fieldType === Number || fieldType === SimpleSchema.Integer) {\n        type = 'number';\n      } else if (fieldType === Boolean) {\n        type = 'boolean';\n      } else if (fieldType === Date) {\n        type = 'date';\n      } else if (fieldType === Array) {\n        var arrayItemFieldSchema = this.schema(\"\".concat(key, \".$\"));\n        if (!arrayItemFieldSchema) return;\n        var arrayItemFieldType = arrayItemFieldSchema.type.singleType;\n\n        if (arrayItemFieldType === String) {\n          type = 'stringArray';\n        } else if (arrayItemFieldType === Number || arrayItemFieldType === SimpleSchema.Integer) {\n          type = 'numberArray';\n        } else if (arrayItemFieldType === Boolean) {\n          type = 'booleanArray';\n        } else if (arrayItemFieldType === Date) {\n          type = 'dateArray';\n        } else if (arrayItemFieldType === Object || SimpleSchema.isSimpleSchema(arrayItemFieldType)) {\n          type = 'objectArray';\n        }\n      } else if (fieldType === Object) {\n        type = 'object';\n      }\n\n      return type;\n    }\n    /**\n     * Given a key that is an Object, returns a new SimpleSchema instance scoped to that object.\n     *\n     * @param {String} key Generic or specific schema key\n     */\n\n  }, {\n    key: \"getObjectSchema\",\n    value: function getObjectSchema(key) {\n      var newSchemaDef = {};\n\n      var genericKey = _mongoObject[\"default\"].makeKeyGeneric(key);\n\n      var searchString = \"\".concat(genericKey, \".\");\n      var mergedSchema = this.mergedSchema();\n      Object.keys(mergedSchema).forEach(function (k) {\n        if (k.indexOf(searchString) === 0) {\n          newSchemaDef[k.slice(searchString.length)] = mergedSchema[k];\n        }\n      });\n      return this._copyWithSchema(newSchemaDef);\n    } // Returns an array of all the autovalue functions, including those in subschemas all the\n    // way down the schema tree\n\n  }, {\n    key: \"autoValueFunctions\",\n    value: function autoValueFunctions() {\n      var _this4 = this;\n\n      var result = [].concat(this._autoValues);\n\n      this._schemaKeys.forEach(function (key) {\n        _this4._schema[key].type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          result = result.concat(typeDef.type.autoValueFunctions().map(function (_ref2) {\n            var func = _ref2.func,\n                fieldName = _ref2.fieldName,\n                closestSubschemaFieldName = _ref2.closestSubschemaFieldName;\n            return {\n              func: func,\n              fieldName: \"\".concat(key, \".\").concat(fieldName),\n              closestSubschemaFieldName: closestSubschemaFieldName.length ? \"\".concat(key, \".\").concat(closestSubschemaFieldName) : key\n            };\n          }));\n        });\n      });\n\n      return result;\n    } // Returns an array of all the blackbox keys, including those in subschemas\n\n  }, {\n    key: \"blackboxKeys\",\n    value: function blackboxKeys() {\n      var _this5 = this;\n\n      var blackboxKeys = this._blackboxKeys;\n\n      this._schemaKeys.forEach(function (key) {\n        _this5._schema[key].type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n\n          typeDef.type._blackboxKeys.forEach(function (blackboxKey) {\n            blackboxKeys.push(\"\".concat(key, \".\").concat(blackboxKey));\n          });\n        });\n      });\n\n      return (0, _lodash6[\"default\"])(blackboxKeys);\n    } // Check if the key is a nested dot-syntax key inside of a blackbox object\n\n  }, {\n    key: \"keyIsInBlackBox\",\n    value: function keyIsInBlackBox(key) {\n      var _this6 = this;\n\n      var isInBlackBox = false;\n      (0, _utility.forEachKeyAncestor)(_mongoObject[\"default\"].makeKeyGeneric(key), function (ancestor, remainder) {\n        if (_this6._blackboxKeys.indexOf(ancestor) > -1) {\n          isInBlackBox = true;\n        } else {\n          var testKeySchema = _this6.schema(ancestor);\n\n          if (testKeySchema) {\n            testKeySchema.type.definitions.forEach(function (typeDef) {\n              if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n              if (typeDef.type.keyIsInBlackBox(remainder)) isInBlackBox = true;\n            });\n          }\n        }\n      });\n      return isInBlackBox;\n    } // Returns true if key is explicitly allowed by the schema or implied\n    // by other explicitly allowed keys.\n    // The key string should have $ in place of any numeric array positions.\n\n  }, {\n    key: \"allowsKey\",\n    value: function allowsKey(key) {\n      var _this7 = this;\n\n      // Loop through all keys in the schema\n      return this._schemaKeys.some(function (loopKey) {\n        // If the schema key is the test key, it's allowed.\n        if (loopKey === key) return true;\n\n        var fieldSchema = _this7.schema(loopKey);\n\n        var compare1 = key.slice(0, loopKey.length + 2);\n        var compare2 = compare1.slice(0, -1); // Blackbox and subschema checks are needed only if key starts with\n        // loopKey + a dot\n\n        if (compare2 !== \"\".concat(loopKey, \".\")) return false; // Black box handling\n\n        if (_this7._blackboxKeys.indexOf(loopKey) > -1) {\n          // If the test key is the black box key + \".$\", then the test\n          // key is NOT allowed because black box keys are by definition\n          // only for objects, and not for arrays.\n          return compare1 !== \"\".concat(loopKey, \".$\");\n        } // Subschemas\n\n\n        var allowed = false;\n        var subKey = key.slice(loopKey.length + 1);\n        fieldSchema.type.definitions.forEach(function (typeDef) {\n          if (!SimpleSchema.isSimpleSchema(typeDef.type)) return;\n          if (typeDef.type.allowsKey(subKey)) allowed = true;\n        });\n        return allowed;\n      });\n    }\n    /**\n     * Returns all the child keys for the object identified by the generic prefix,\n     * or all the top level keys if no prefix is supplied.\n     *\n     * @param {String} [keyPrefix] The Object-type generic key for which to get child keys. Omit for\n     *   top-level Object-type keys\n     * @returns {[[Type]]} [[Description]]\n     */\n\n  }, {\n    key: \"objectKeys\",\n    value: function objectKeys(keyPrefix) {\n      if (!keyPrefix) return this._firstLevelSchemaKeys;\n      return this._objectKeys[\"\".concat(keyPrefix, \".\")] || [];\n    }\n    /**\n     * Copies this schema into a new instance with the same validators, messages,\n     * and options, but with different keys as defined in `schema` argument\n     *\n     * @param {Object} schema\n     * @returns The new SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: \"_copyWithSchema\",\n    value: function _copyWithSchema(schema) {\n      var cl = new SimpleSchema(schema, (0, _clone[\"default\"])(this._constructorOptions, false, 1));\n      cl._cleanOptions = this._cleanOptions;\n      cl.messageBox = this.messageBox.clone();\n      return cl;\n    }\n    /**\n     * Clones this schema into a new instance with the same schema keys, validators,\n     * and options.\n     *\n     * @returns The new SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return this._copyWithSchema(this._schema);\n    }\n    /**\n     * Extends (mutates) this schema with another schema, key by key.\n     *\n     * @param {SimpleSchema|Object} schema\n     * @returns The SimpleSchema instance (chainable)\n     */\n\n  }, {\n    key: \"extend\",\n    value: function extend() {\n      var _this8 = this;\n\n      var schema = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (Array.isArray(schema)) throw new Error('You may not pass an array of schemas to the SimpleSchema constructor or to extend()');\n      var schemaObj;\n\n      if (SimpleSchema.isSimpleSchema(schema)) {\n        schemaObj = schema._schema;\n        this._validators = this._validators.concat(schema._validators);\n        this._docValidators = this._docValidators.concat(schema._docValidators);\n        this._cleanOptions = (0, _extend2[\"default\"])(false, this._cleanOptions, schema._cleanOptions);\n        this._constructorOptions = (0, _extend2[\"default\"])(false, this._constructorOptions, schema._constructorOptions);\n      } else {\n        schemaObj = (0, _expandShorthand[\"default\"])(schema);\n      } // Update all of the information cached on the instance\n\n\n      Object.keys(schemaObj).forEach(function (fieldName) {\n        var definition = standardizeDefinition(schemaObj[fieldName]); // Merge/extend with any existing definition\n\n        if (_this8._schema[fieldName]) {\n          if (!_this8._schema.hasOwnProperty(fieldName)) {\n            // fieldName is actually a method from Object itself!\n            throw new Error(\"\".concat(fieldName, \" key is actually the name of a method on Object, please rename it\"));\n          }\n\n          _this8._schema[fieldName] = _objectSpread({}, _this8._schema[fieldName], {}, (0, _lodash4[\"default\"])(definition, 'type'));\n          if (definition.type) _this8._schema[fieldName].type.extend(definition.type);\n        } else {\n          _this8._schema[fieldName] = definition;\n        }\n\n        checkAndScrubDefinition(fieldName, _this8._schema[fieldName], _this8._constructorOptions, schemaObj);\n      });\n      checkSchemaOverlap(this._schema); // Set/Reset all of these\n\n      this._schemaKeys = Object.keys(this._schema);\n      this._autoValues = [];\n      this._blackboxKeys = [];\n      this._firstLevelSchemaKeys = [];\n      this._objectKeys = {}; // Update all of the information cached on the instance\n\n      this._schemaKeys.forEach(function (fieldName) {\n        // Make sure parent has a definition in the schema. No implied objects!\n        if (fieldName.indexOf('.') > -1) {\n          var parentFieldName = fieldName.slice(0, fieldName.lastIndexOf('.'));\n          if (!_this8._schema.hasOwnProperty(parentFieldName)) throw new Error(\"\\\"\".concat(fieldName, \"\\\" is in the schema but \\\"\").concat(parentFieldName, \"\\\" is not\"));\n        }\n\n        var definition = _this8._schema[fieldName]; // Keep list of all top level keys\n\n        if (fieldName.indexOf('.') === -1) _this8._firstLevelSchemaKeys.push(fieldName); // Keep list of all blackbox keys for passing to MongoObject constructor\n        // XXX For now if any oneOf type is blackbox, then the whole field is.\n\n        (0, _lodash[\"default\"])(definition.type.definitions, function (oneOfDef) {\n          if (oneOfDef.blackbox === true) {\n            _this8._blackboxKeys.push(fieldName);\n\n            return false; // exit loop\n          }\n\n          return true;\n        }); // Keep list of autoValue functions\n\n        if (typeof definition.autoValue === 'function') {\n          _this8._autoValues.push({\n            closestSubschemaFieldName: '',\n            fieldName: fieldName,\n            func: definition.autoValue\n          });\n        }\n      }); // Store child keys keyed by parent. This needs to be done recursively to handle\n      // subschemas.\n\n\n      var setObjectKeys = function setObjectKeys(curSchema, schemaParentKey) {\n        Object.keys(curSchema).forEach(function (fieldName) {\n          var definition = curSchema[fieldName];\n          fieldName = schemaParentKey ? \"\".concat(schemaParentKey, \".\").concat(fieldName) : fieldName;\n\n          if (fieldName.indexOf('.') > -1 && fieldName.slice(-2) !== '.$') {\n            var parentKey = fieldName.slice(0, fieldName.lastIndexOf('.'));\n            var parentKeyWithDot = \"\".concat(parentKey, \".\");\n            _this8._objectKeys[parentKeyWithDot] = _this8._objectKeys[parentKeyWithDot] || [];\n\n            _this8._objectKeys[parentKeyWithDot].push(fieldName.slice(fieldName.lastIndexOf('.') + 1));\n          } // If the current field is a nested SimpleSchema,\n          // iterate over the child fields and cache their properties as well\n\n\n          definition.type.definitions.forEach(function (_ref3) {\n            var type = _ref3.type;\n\n            if (SimpleSchema.isSimpleSchema(type)) {\n              setObjectKeys(type._schema, fieldName);\n            }\n          });\n        });\n      };\n\n      setObjectKeys(this._schema);\n      return this;\n    }\n  }, {\n    key: \"getAllowedValuesForKey\",\n    value: function getAllowedValuesForKey(key) {\n      // For array fields, `allowedValues` is on the array item definition\n      if (this.allowsKey(\"\".concat(key, \".$\"))) {\n        key = \"\".concat(key, \".$\");\n      }\n\n      var allowedValues = this.get(key, 'allowedValues');\n      return (0, _lodash3[\"default\"])(allowedValues) ? null : _toConsumableArray(allowedValues);\n    }\n  }, {\n    key: \"newContext\",\n    value: function newContext() {\n      return new _ValidationContext[\"default\"](this);\n    }\n  }, {\n    key: \"namedContext\",\n    value: function namedContext(name) {\n      if (typeof name !== 'string') name = 'default';\n\n      if (!this._validationContexts[name]) {\n        this._validationContexts[name] = new _ValidationContext[\"default\"](this);\n      }\n\n      return this._validationContexts[name];\n    }\n  }, {\n    key: \"addValidator\",\n    value: function addValidator(func) {\n      this._validators.push(func);\n    }\n  }, {\n    key: \"addDocValidator\",\n    value: function addDocValidator(func) {\n      this._docValidators.push(func);\n    }\n    /**\n     * @param obj {Object|Object[]} Object or array of objects to validate.\n     * @param [options] {Object} Same options object that ValidationContext#validate takes\n     *\n     * Throws an Error with name `ClientError` and `details` property containing the errors.\n     */\n\n  }, {\n    key: \"validate\",\n    value: function validate(obj) {\n      var _this9 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // For Meteor apps, `check` option can be passed to silence audit-argument-checks\n      var check = options.check || this._constructorOptions.check;\n\n      if (typeof check === 'function') {\n        // Call check but ignore the error\n        try {\n          check(obj);\n        } catch (e) {\n          /* ignore error */\n        }\n      } // obj can be an array, in which case we validate each object in it and\n      // throw as soon as one has an error\n\n\n      var objects = Array.isArray(obj) ? obj : [obj];\n      objects.forEach(function (oneObj) {\n        var validationContext = _this9.newContext();\n\n        var isValid = validationContext.validate(oneObj, options);\n        if (isValid) return;\n        var errors = validationContext.validationErrors(); // In order for the message at the top of the stack trace to be useful,\n        // we set it to the first validation error message.\n\n        var message = _this9.messageForError(errors[0]);\n\n        var error = new Error(message);\n        error.name = error.errorType = 'ClientError';\n        error.error = 'validation-error'; // Add meaningful error messages for each validation error.\n        // Useful for display messages when using 'mdg:validated-method'.\n\n        error.details = errors.map(function (errorDetail) {\n          return _objectSpread({}, errorDetail, {\n            message: _this9.messageForError(errorDetail)\n          });\n        }); // The primary use for the validationErrorTransform is to convert the\n        // vanilla Error into a Meteor.Error until DDP is able to pass\n        // vanilla errors back to the client.\n\n        if (typeof SimpleSchema.validationErrorTransform === 'function') {\n          throw SimpleSchema.validationErrorTransform(error);\n        } else {\n          throw error;\n        }\n      });\n    }\n    /**\n     * @param obj {Object} Object to validate.\n     * @param [options] {Object} Same options object that ValidationContext#validate takes\n     *\n     * Returns a Promise that resolves with the errors\n     */\n\n  }, {\n    key: \"validateAndReturnErrorsPromise\",\n    value: function validateAndReturnErrorsPromise(obj, options) {\n      var _this10 = this;\n\n      var validationContext = this.newContext();\n      var isValid = validationContext.validate(obj, options);\n      if (isValid) return Promise.resolve([]); // Add the `message` prop\n\n      var errors = validationContext.validationErrors().map(function (errorDetail) {\n        return _objectSpread({}, errorDetail, {\n          message: _this10.messageForError(errorDetail)\n        });\n      });\n      return Promise.resolve(errors);\n    }\n  }, {\n    key: \"validator\",\n    value: function validator() {\n      var _this11 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return function (obj) {\n        var optionsClone = _objectSpread({}, options);\n\n        if (options.clean === true) {\n          // Do this here and pass into both functions for better performance\n          optionsClone.mongoObject = new _mongoObject[\"default\"](obj, _this11.blackboxKeys());\n\n          _this11.clean(obj, optionsClone);\n        }\n\n        if (options.returnErrorsPromise) {\n          return _this11.validateAndReturnErrorsPromise(obj, optionsClone);\n        }\n\n        return _this11.validate(obj, optionsClone);\n      };\n    }\n  }, {\n    key: \"getFormValidator\",\n    value: function getFormValidator() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.validator(_objectSpread({}, options, {\n        returnErrorsPromise: true\n      }));\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return _clean2[\"default\"].apply(void 0, [this].concat(args));\n    }\n    /**\n     * Change schema labels on the fly, causing mySchema.label computation\n     * to rerun. Useful when the user changes the language.\n     *\n     * @param {Object} labels A dictionary of all the new label values, by schema key.\n     */\n\n  }, {\n    key: \"labels\",\n    value: function labels(_labels) {\n      var _this12 = this;\n\n      Object.keys(_labels).forEach(function (key) {\n        var label = _labels[key];\n        if (typeof label !== 'string' && typeof label !== 'function') return;\n        if (!_this12._schema.hasOwnProperty(key)) return;\n        _this12._schema[key].label = label;\n        _this12._depsLabels[key] && _this12._depsLabels[key].changed();\n      });\n    }\n    /**\n     * Gets a field's label or all field labels reactively.\n     *\n     * @param {String} [key] The schema key, specific or generic.\n     *   Omit this argument to get a dictionary of all labels.\n     * @returns {String} The label\n     */\n\n  }, {\n    key: \"label\",\n    value: function label(key) {\n      var _this13 = this;\n\n      // Get all labels\n      if (key === null || key === undefined) {\n        var result = {};\n\n        this._schemaKeys.forEach(function (schemaKey) {\n          result[schemaKey] = _this13.label(schemaKey);\n        });\n\n        return result;\n      } // Get label for one field\n\n\n      var label = this.get(key, 'label');\n      if (label) this.reactiveLabelDependency(key);\n      return label || null;\n    }\n    /**\n     * Gets a field's property\n     *\n     * @param {String} key The schema key, specific or generic.\n     * @param {String} prop Name of the property to get for that schema key\n     * @param {Object} [functionContext] The `this` context to use if prop is a function\n     * @returns {any} The property value\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(key, prop, functionContext) {\n      var def = this.getDefinition(key, ['type', prop], functionContext);\n      if (!def) return undefined;\n\n      if ((0, _lodash2[\"default\"])(schemaDefinitionOptions, prop)) {\n        return def[prop];\n      }\n\n      return (def.type.find(function (props) {\n        return props[prop];\n      }) || {})[prop];\n    } // shorthand for getting defaultValue\n\n  }, {\n    key: \"defaultValue\",\n    value: function defaultValue(key) {\n      return this.get(key, 'defaultValue');\n    } // Returns a string message for the given error type and key. Passes through\n    // to message-box pkg.\n\n  }, {\n    key: \"messageForError\",\n    value: function messageForError(errorInfo) {\n      var name = errorInfo.name;\n      return this.messageBox.message(errorInfo, {\n        context: {\n          key: name,\n          // backward compatibility\n          // The call to this.label() establishes a reactive dependency, too\n          label: this.label(name)\n        }\n      });\n    }\n    /**\n     * @method SimpleSchema#pick\n     * @param {[fields]} The list of fields to pick to instantiate the subschema\n     * @returns {SimpleSchema} The subschema\n     */\n\n  }], [{\n    key: \"isSimpleSchema\",\n    value: function isSimpleSchema(obj) {\n      return obj && (obj instanceof SimpleSchema || obj._schema);\n    }\n  }, {\n    key: \"extendOptions\",\n    // If you need to allow properties other than those listed above, call this from your app or package\n    value: function extendOptions(options) {\n      // For backwards compatibility we still take an object here, but we only care about the names\n      if (!Array.isArray(options)) options = Object.keys(options);\n      options.forEach(function (option) {\n        schemaDefinitionOptions.push(option);\n      });\n    }\n  }, {\n    key: \"defineValidationErrorTransform\",\n    value: function defineValidationErrorTransform(transform) {\n      if (typeof transform !== 'function') {\n        throw new Error('SimpleSchema.defineValidationErrorTransform must be passed a function that accepts an Error and returns an Error');\n      }\n\n      SimpleSchema.validationErrorTransform = transform;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(obj, schema, options) {\n      // Allow passing just the schema object\n      if (!SimpleSchema.isSimpleSchema(schema)) {\n        schema = new SimpleSchema(schema);\n      }\n\n      return schema.validate(obj, options);\n    }\n  }, {\n    key: \"oneOf\",\n    value: function oneOf() {\n      for (var _len2 = arguments.length, definitions = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        definitions[_key2] = arguments[_key2];\n      }\n\n      return _construct(_SimpleSchemaGroup[\"default\"], definitions);\n    }\n  }, {\n    key: \"addValidator\",\n    value: function addValidator(func) {\n      SimpleSchema._validators.push(func);\n    }\n  }, {\n    key: \"addDocValidator\",\n    value: function addDocValidator(func) {\n      SimpleSchema._docValidators.push(func);\n    }\n  }]);\n\n  return SimpleSchema;\n}();\n/*\n * PRIVATE\n */\n// Throws an error if any fields are `type` SimpleSchema but then also\n// have subfields defined outside of that.\n\n\nexports.SimpleSchema = SimpleSchema;\n\n_defineProperty(SimpleSchema, \"version\", 2);\n\n_defineProperty(SimpleSchema, \"RegEx\", _regExp[\"default\"]);\n\n_defineProperty(SimpleSchema, \"_validators\", []);\n\n_defineProperty(SimpleSchema, \"_docValidators\", []);\n\n_defineProperty(SimpleSchema, \"ErrorTypes\", {\n  REQUIRED: 'required',\n  MIN_STRING: 'minString',\n  MAX_STRING: 'maxString',\n  MIN_NUMBER: 'minNumber',\n  MAX_NUMBER: 'maxNumber',\n  MIN_NUMBER_EXCLUSIVE: 'minNumberExclusive',\n  MAX_NUMBER_EXCLUSIVE: 'maxNumberExclusive',\n  MIN_DATE: 'minDate',\n  MAX_DATE: 'maxDate',\n  BAD_DATE: 'badDate',\n  MIN_COUNT: 'minCount',\n  MAX_COUNT: 'maxCount',\n  MUST_BE_INTEGER: 'noDecimal',\n  VALUE_NOT_ALLOWED: 'notAllowed',\n  EXPECTED_TYPE: 'expectedType',\n  FAILED_REGULAR_EXPRESSION: 'regEx',\n  KEY_NOT_IN_SCHEMA: 'keyNotInSchema'\n});\n\n_defineProperty(SimpleSchema, \"Integer\", 'SimpleSchema.Integer');\n\n_defineProperty(SimpleSchema, \"_makeGeneric\", _mongoObject[\"default\"].makeKeyGeneric);\n\n_defineProperty(SimpleSchema, \"ValidationContext\", _ValidationContext[\"default\"]);\n\n_defineProperty(SimpleSchema, \"setDefaultMessages\", function (messages) {\n  (0, _extend2[\"default\"])(true, _defaultMessages[\"default\"], messages);\n});\n\nfunction checkSchemaOverlap(schema) {\n  Object.keys(schema).forEach(function (key) {\n    var val = schema[key];\n    if (!val.type) throw new Error(\"\".concat(key, \" key is missing \\\"type\\\"\"));\n    val.type.definitions.forEach(function (def) {\n      if (!SimpleSchema.isSimpleSchema(def.type)) return;\n      Object.keys(def.type._schema).forEach(function (subKey) {\n        var newKey = \"\".concat(key, \".\").concat(subKey);\n\n        if (schema.hasOwnProperty(newKey)) {\n          throw new Error(\"The type for \\\"\".concat(key, \"\\\" is set to a SimpleSchema instance that defines \\\"\").concat(key, \".\").concat(subKey, \"\\\", but the parent SimpleSchema instance also tries to define \\\"\").concat(key, \".\").concat(subKey, \"\\\"\"));\n        }\n      });\n    });\n  });\n}\n/**\n * @param {String} fieldName The full generic schema key\n * @param {Boolean} shouldHumanize Humanize it\n * @returns {String} A label based on the key\n */\n\n\nfunction inflectedLabel(fieldName, shouldHumanize) {\n  var pieces = fieldName.split('.');\n  var label;\n\n  do {\n    label = pieces.pop();\n  } while (label === '$' && pieces.length);\n\n  return shouldHumanize ? (0, _humanize[\"default\"])(label) : label;\n}\n\nfunction getDefaultAutoValueFunction(defaultValue) {\n  return function defaultAutoValueFunction() {\n    if (this.isSet) return;\n    if (this.operator === null) return defaultValue; // Handle the case when pulling an object from an array the object contains a field\n    // which has a defaultValue. We don't want the default value to be returned in this case\n\n    if (this.operator === '$pull') return; // Handle the case where we are $pushing an object into an array of objects and we\n    // want any fields missing from that object to be added if they have default values\n\n    if (this.operator === '$push') return defaultValue; // If parent is set, we should update this position instead of $setOnInsert\n\n    if (this.parentField().isSet) return defaultValue; // Make sure the default value is added on upsert insert\n\n    if (this.isUpsert) return {\n      $setOnInsert: defaultValue\n    };\n  };\n} // Mutates def into standardized object with SimpleSchemaGroup type\n\n\nfunction standardizeDefinition(def) {\n  var standardizedDef = (0, _lodash4[\"default\"])(def, oneOfProps); // Internally, all definition types are stored as groups for simplicity of access.\n  // If we are extending, there may not actually be def.type, but it's okay because\n  // it will be added later when the two SimpleSchemaGroups are merged.\n\n  if (def.type && def.type instanceof _SimpleSchemaGroup[\"default\"]) {\n    standardizedDef.type = def.type.clone();\n  } else {\n    var groupProps = (0, _lodash5[\"default\"])(def, oneOfProps);\n    standardizedDef.type = new _SimpleSchemaGroup[\"default\"](groupProps);\n  }\n\n  return standardizedDef;\n} // Checks and mutates definition. Clone it first.\n\n\nfunction checkAndScrubDefinition(fieldName, definition, options, fullSchemaObj) {\n  if (!definition.type) throw new Error(\"\".concat(fieldName, \" key is missing \\\"type\\\"\")); // Validate the field definition\n\n  Object.keys(definition).forEach(function (key) {\n    if (schemaDefinitionOptions.indexOf(key) === -1) {\n      throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"\").concat(key, \"\\\" is not a supported property\"));\n    }\n  }); // Make sure the `type`s are OK\n\n  var couldBeArray = false;\n  definition.type.definitions.forEach(function (_ref4) {\n    var type = _ref4.type;\n    if (!type) throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"type\\\" option is required\"));\n\n    if (Array.isArray(type)) {\n      throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"type\\\" may not be an array. Change it to Array.\"));\n    }\n\n    if (type.constructor === Object && (0, _lodash3[\"default\"])(type)) {\n      throw new Error(\"Invalid definition for \".concat(fieldName, \" field: \\\"type\\\" may not be an object. Change it to Object\"));\n    }\n\n    if (type === Array) couldBeArray = true;\n\n    if (SimpleSchema.isSimpleSchema(type)) {\n      Object.keys(type._schema).forEach(function (subKey) {\n        var newKey = \"\".concat(fieldName, \".\").concat(subKey);\n\n        if (fullSchemaObj.hasOwnProperty(newKey)) {\n          throw new Error(\"The type for \\\"\".concat(fieldName, \"\\\" is set to a SimpleSchema instance that defines \\\"\").concat(newKey, \"\\\", but the parent SimpleSchema instance also tries to define \\\"\").concat(newKey, \"\\\"\"));\n        }\n      });\n    }\n  }); // If at least one of the possible types is Array, then make sure we have a\n  // definition for the array items, too.\n\n  if (couldBeArray && !fullSchemaObj.hasOwnProperty(\"\".concat(fieldName, \".$\"))) {\n    throw new Error(\"\\\"\".concat(fieldName, \"\\\" is Array type but the schema does not include a \\\"\").concat(fieldName, \".$\\\" definition for the array items\\\"\"));\n  } // defaultValue -> autoValue\n  // We support defaultValue shortcut by converting it immediately into an\n  // autoValue.\n\n\n  if ('defaultValue' in definition) {\n    if ('autoValue' in definition && !definition.autoValue.isDefault) {\n      console.warn(\"SimpleSchema: Found both autoValue and defaultValue options for \\\"\".concat(fieldName, \"\\\". Ignoring defaultValue.\"));\n    } else {\n      if (fieldName.endsWith('.$')) {\n        throw new Error('An array item field (one that ends with \".$\") cannot have defaultValue.');\n      }\n\n      definition.autoValue = getDefaultAutoValueFunction(definition.defaultValue);\n      definition.autoValue.isDefault = true;\n    }\n  } // REQUIREDNESS\n\n\n  if (fieldName.endsWith('.$')) {\n    definition.optional = true;\n  } else {\n    if (!definition.hasOwnProperty('optional')) {\n      if (definition.hasOwnProperty('required')) {\n        if (typeof definition.required === 'function') {\n          definition.optional = function optional() {\n            for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n              args[_key3] = arguments[_key3];\n            }\n\n            return !definition.required.apply(this, args);\n          };\n        } else {\n          definition.optional = !definition.required;\n        }\n      } else {\n        definition.optional = options.requiredByDefault === false;\n      }\n    }\n  }\n\n  delete definition.required; // LABELS\n\n  if (!definition.hasOwnProperty('label')) {\n    if (options.defaultLabel) {\n      definition.label = options.defaultLabel;\n    } else if (SimpleSchema.defaultLabel) {\n      definition.label = SimpleSchema.defaultLabel;\n    } else {\n      definition.label = inflectedLabel(fieldName, options.humanizeAutoLabels);\n    }\n  }\n}\n\nfunction getPickOrOmit(type) {\n  return function pickOrOmit() {\n    var _this14 = this;\n\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    // If they are picking/omitting an object or array field, we need to also include everything under it\n    var newSchema = {};\n\n    this._schemaKeys.forEach(function (key) {\n      // Pick/omit it if it IS in the array of keys they want OR if it\n      // STARTS WITH something that is in the array plus a period\n      var includeIt = args.some(function (wantedField) {\n        return key === wantedField || key.indexOf(\"\".concat(wantedField, \".\")) === 0;\n      });\n\n      if (includeIt && type === 'pick' || !includeIt && type === 'omit') {\n        newSchema[key] = _this14._schema[key];\n      }\n    });\n\n    return this._copyWithSchema(newSchema);\n  };\n}"]},"metadata":{},"sourceType":"script"}